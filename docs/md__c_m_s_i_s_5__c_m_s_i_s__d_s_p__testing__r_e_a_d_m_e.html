<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AME: TEST FRAMEWORK</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">AME
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('md__c_m_s_i_s_5__c_m_s_i_s__d_s_p__testing__r_e_a_d_m_e.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">TEST FRAMEWORK </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This framework is for our own internal use. We decided to release it but, at least in short term, we won't give any help or support about it.</p>
<h1><a class="anchor" id="autotoc_md24"></a>
REQUIREMENTS</h1>
<h2><a class="anchor" id="autotoc_md25"></a>
Test descriptions</h2>
<h3><a class="anchor" id="autotoc_md26"></a>
R1 : The tests shall be described in a file</h3>
<p>We need a source of truth which is describing all the tests and can be used to generate code, format output etc ...</p>
<h3><a class="anchor" id="autotoc_md27"></a>
R2 : The test description should support a hierarchy</h3>
<p>We have lots of tests. We need to be able to organize them in a hierarchical way</p>
<h3><a class="anchor" id="autotoc_md28"></a>
R3 : A test shall be uniquely identified</h3>
<p>We need a way to identify in an unique way each test to ensure traceability and enable to create history of test results and benchmark.</p>
<h3><a class="anchor" id="autotoc_md29"></a>
R4 : The unique identifier shall not change when tests are added or removed.</h3>
<p>It is important to keep traceability.</p>
<h3><a class="anchor" id="autotoc_md30"></a>
R5 : The test description shall list the test patterns and input patterns required by the tests</h3>
<h3><a class="anchor" id="autotoc_md31"></a>
R6 : It shall be possible to parametrize the tests</h3>
<p>For benchmarking, we may need to vary some dimensions of the tests (like input length). The tests may depend on several parameters (width, height etc ...) We need to be able to specify how those parameters are varied.</p>
<h3><a class="anchor" id="autotoc_md32"></a>
R7 : It shall be possible to specify a subset of parameters (which could be empty) to compute regression.</h3>
<p>For instance, if our test is dependent on a vector size, we may want to compute a linear regression to know how the performances are dependent on the vector size.</p>
<p>But, our test may also depend on another parameter B which is not interesting us in the regression. In that case, the regression formula should not take into account B. And we would have several regression formula for each value of the parameter B.</p>
<p>The parameters of the tests would be Vector Size and B but the Summary parameter only Vector Size.</p>
<h3><a class="anchor" id="autotoc_md33"></a>
R8 : The concept of a test suite shall be supported.</h3>
<p>A test suite is a set of tests packaged with some data.</p>
<h2><a class="anchor" id="autotoc_md34"></a>
Test execution</h2>
<p>For following requirements, we define a device under tests (DUT) as the place where the function to test is executed. But the test itself (to check that the execution has been successful could be running on the DUT or on a host like a PC).</p>
<h3><a class="anchor" id="autotoc_md35"></a>
R9 : The memory should be cleaned between 2 tests</h3>
<p>A test should start (as far as possible) in a clean state. There should not be interferences between the tests.</p>
<h3><a class="anchor" id="autotoc_md36"></a>
R10 : The test may be run on the DUT or on the host</h3>
<h3><a class="anchor" id="autotoc_md37"></a>
R11 : Output of tested functions could be dumped or not</h3>
<h3><a class="anchor" id="autotoc_md38"></a>
R12 : The tested function should not know where are the patterns and how to get them</h3>
<h3><a class="anchor" id="autotoc_md39"></a>
R13 : Control of the tests could run on the DUT but could also be run on a host</h3>
<h3><a class="anchor" id="autotoc_md40"></a>
R14 : Summary of test execution shall support several formats</h3>
<p>(CSV, HTML, Text etc ...)</p>
<h3><a class="anchor" id="autotoc_md41"></a>
R15 : One should not assume the test environment on the DUT has access to IOs.</h3>
<h1><a class="anchor" id="autotoc_md42"></a>
DESIGN PRINCIPLES</h1>
<p>The design is a consequence of all the requirements.</p>
<h2><a class="anchor" id="autotoc_md43"></a>
Test description</h2>
<p>A test description file is defined with a specific syntax to support R1 to R8.</p>
<h3><a class="anchor" id="autotoc_md44"></a>
Hierachical structure</h3>
<pre class="fragment">group Root {
    class = Root
    group DSP Test {
        class = DSPTest
        folder = DSP
        suite Basic Tests {
           class = BasicTests
           folder = BasicMaths
</pre><p> The tests are organized in a hierarchy. For each node of the hierarchy, a C++ class is specified. The script processTest.py is generating C++ codee for the group. For the test suite, the script is generating a partial implementation since a test suite is containing tests and you need to add the test themselves.</p>
<p>The patterns, output of tests, parameters are also following a hierarchical structure. But they do not need to be organized in exactly the same way. So, the folder property of a node is optional.</p>
<p>A folder can be reused for different nodes. For instance, you may have a suite for testing and one for benchmarking and both may use the same pattern folder.</p>
<p>A test suite is more complex than a group since it contains the description of the tests and related information.</p>
<h3><a class="anchor" id="autotoc_md45"></a>
Test suite</h3>
<p>The simplest suite is just containing functions: </p><pre class="fragment">suite Basic Tests {
       class = BasicTests
       folder = BasicMaths

       Functions {
         Test arm_add_f32:test_add_f32
       }
}
</pre><p> A function is described with some text and followed by the name of the function in the C++ class. The text is used when reporting the results of the tests.</p>
<p>The same function can be used for different tests in the suite. The tests will be different due to different input data or parameters.</p>
<p>A test is requiring input patterns, reference patterns and outputs (to be compared to the reference). Since the test must not know where is the data and how to get it, this information is provided in the test description file.</p>
<p>So, the test suite would be: </p><pre class="fragment">suite Basic Tests {
       class = BasicTests
       folder = BasicMaths

       Pattern INPUT1_F32_ID : Input1_f32.txt 
       Pattern INPUT2_F32_ID : Input2_f32.txt 
       Pattern REF_ADD_F32_ID : Reference1_f32.txt
       Output  OUT_SAMPLES_F32_ID : Output

       Functions {
         Test arm_add_f32:test_add_f32
       }
}
</pre><p> A pattern or output description is an ID (to be used in the code) followed by a filename.</p>
<p>The file is in the folder defined with the folder properties of the group / suites.</p>
<p>The root folder for pattern files and output files is different.</p>
<h3><a class="anchor" id="autotoc_md46"></a>
Benchmarks</h3>
<p>A benchmark will often have to be run with different lengths for the input. So we need a way to communicate arguments to a function.</p>
<p>We make the assumption that those arguments are integers. In the benchmark results, we may want to generate a CSV (or any other format) with different columns for those arguments.</p>
<p>And we may want to compute a regression formula using only a subset of those arguments.</p>
<p>So, we have the possibility in the suite section to add a parameter section to describe all of this. </p><pre class="fragment">suite Complex Tests {
        class = ComplexTests
        folder = ComplexMaths

        ParamList {
            A,B,C
            Summary A,B
            Names "Param A", "Param B"
            Formula "A*B"
        }

        Pattern INPUT1_F32_ID : Input1_f32.txt 
</pre><p>In above example we declare that the functions of the suite are using 3 parameters named A,B and C. We declare that a regression formula will use only A and B. So for each C value, we will get a different regression formula.</p>
<p>We list the names to use when formatting the output of benchmarks. We define a regression formula using R syntax. (We do not write "cycles ~ A*B" but only "A*B")</p>
<p>Once parameters have been described, we need a way to feed parameter values to a test.</p>
<p>There are 2 ways. First way is a parameter file. Problem of a parameter file when it has to be included in the test (C array) is that it may be big. So, we also have a parameter generator. It is less flexible but enough for lot of cases.</p>
<p>Those parameters values, when specified with a file, are described with: </p><pre class="fragment">        Output  OUT_SAMPLES_F32_ID : Output
        Params PARAM1_ID : Params1.txt
</pre><p> They follow the outputs section and use similar syntax.</p>
<p>When the parameter is specified with a generator then the syntax is : </p><pre class="fragment">Params PARAM3_ID = {
            A = [1,3,5]
            B = [1,3,5]
            C = [1,3,5]
        }
</pre><p> This generator will compute the cartesian product of the 3 lists.</p>
<p>To use parameters with a function the syntax is: </p><pre class="fragment">Functions {
           Test A:testA -&gt; PARAM3_ID
        } -&gt; PARAM1_ID
</pre><p> PARAM1_ID is the default applied to all functions. In this example we decide to use PARAM3_ID for the testA function.</p>
<h3><a class="anchor" id="autotoc_md47"></a>
File formats</h3>
<p>Pattern files have the following format: </p><pre class="fragment">W
128
// 1.150898
0x3f93509c
...
</pre><p>First line if the word size (W,H or B) Second line is the number of samples Then for each samples we have an human representation of the value: // 1.150898</p>
<p>and an hexadecimal representation 0x3f93509c</p>
<p>Output files are only containing the hexadecimal values.</p>
<p>Parameters files have the following format: </p><pre class="fragment">81
1
1
1
1
1
3
...
</pre><p> First line is the number of samples. Then the samples.</p>
<p>First line must be a multiple of the number of parameters. In our above example we have 3 parameters A,B,C. So, the number of possible run must be a multiple of 3 since we need to specify values for all parameters.</p>
<h3><a class="anchor" id="autotoc_md48"></a>
disabled</h3>
<p>Any node (Group, Suite or Function) can be disabled by using disabled { ...}.</p>
<p>A disabled group/suite/test is not executed (and its code not generated for group/suite). Using disabled for tests is allowing to disable a test without changing the test ID of following tests.</p>
<h2><a class="anchor" id="autotoc_md49"></a>
Memory manager</h2>
<p>Memory manager is coming from requirement R9 Its API is defined by virtual class Memory. An implementation ArrayMemory is provided which is using a buffer. The details of the APIs are in <a class="el" href="_test_8h_source.html">Test.h</a></p>
<p>A memory manager can provide new buffer, free all the already allocated buffers and give a generation number which is incremented each time all buffer are released.</p>
<h3><a class="anchor" id="autotoc_md50"></a>
Runner</h3>
<p>According to R13 , the test may be controlled on the DUT or from an external host. It is implemented with a Runner class. The only implementation provided is IORunner,</p>
<p>A Runner is just an implementation of the visitor pattern. A runner is applied to the tree of tests. In case of the IO runner, an IO mechanism and a memory manager must be provided.</p>
<p>The runner is running a test and for benchmark measuring the cycles. Cycles measurement can be based on internal counter or external trace. Generally, there is a calibration at beginning of the Runner to estimate the overhead of cycle measurements. This overhead is then removed when doing the measurement.</p>
<h3><a class="anchor" id="autotoc_md51"></a>
IO</h3>
<p>According to R12 and R15, tests do not know how to access patterns. It is a responsiblity implemented with the IO, Pattern and PatternMgr.</p>
<p>IO is about loading patterns and dumping output. It is not about IO in general. We provide 2 IO implementations : Semihosting and FPGA.</p>
<p>FPGA is when you need to run the tests in a constrained environment where you only have stdout. The inputs of tests are in C array. The script processTest.py will generate those C arrays.</p>
<p>Patterns is the interface to patterns and output from the test point of view. They will return NULL when a pattern is still referencing a generation of memory older than the current one.</p>
<p>PatternMgr is the link between IO and Memory and knows how to load a pattern and save it into memory.</p>
<h3><a class="anchor" id="autotoc_md52"></a>
Dump feature</h3>
<p>According to R10 and R11, one must be able to disable tests done on the DUT and dump the output so that the test itself can be done on the host. When instantiating a runner, you can specify the running mode with an enum. For instance Testing::kTestAndDump. There are 3 modes, Test only, Dump only, Test and dump.</p>
<p>In dump only mode, tests using pattern will fail but the tests will be considered as passed (because we are only interested in the output).</p>
<p>But it means that no test using patterns shoudl be used in the middle of the test or some part of it may not be executed. Those tests must be kept at the end.</p>
<h3><a class="anchor" id="autotoc_md53"></a>
processResult</h3>
<p>For R14, we have a python script which will process the result of tests and format it into several possible formats like text, CSV, Mathematica dataset.</p>
<h1><a class="anchor" id="autotoc_md54"></a>
HOW TO RUN IT</h1>
<h2><a class="anchor" id="autotoc_md55"></a>
Needed packages</h2>
<pre class="fragment">pip install pyparsing 
pip install Colorama
</pre><p> If you want to compute summary statistics with regression: </p><pre class="fragment">pip install statsmodels
pip install numpy
pip install panda
</pre><p> If you want to run the script which is launching all the tests on all possible configurations then you'll need yaml: </p><pre class="fragment">pip install pyyaml
</pre> <h2><a class="anchor" id="autotoc_md56"></a>
Generate the test patterns in Patterns folder</h2>
<p>We have archived lot of test patterns on github. So this step is needed only if you write new test patterns. </p><pre class="fragment">cd Testing
python PatternGeneration\BasicMaths.py
</pre><h2><a class="anchor" id="autotoc_md57"></a>
Generate the cpp,h and txt files from the desc.txt file</h2>
<p>First time the project is cloned from github, you'll need to create some missing folders as done in the script createDefaultFolder.sh</p>
<p>Those folders are used to contain the files generated by the scripts.</p>
<p>Once those folders have been created. You can use following commands to create the generated C files. </p><pre class="fragment">cd ..

python preprocess.py -f desc.txt 
</pre><p> This will create a file Output.pickle which is containing a Python object representing the parsed data structure. It is done because parsing a big test description file is quite slow.</p>
<p>So, it is needed to be done only once or if you modify the test description file.</p>
<p>Then, the tests can be processed to configure the test environment with </p><pre class="fragment">python processTests.py -f Output.pickle
</pre><p> or just </p><pre class="fragment">python processTests.py
</pre><p> You can also use the -e option (for embedded). It will include all the patterns (for the selected tests) into a C array. It is the preferred method if you want to run on a board. In below examples, we will always use -e option. </p><pre class="fragment">python processTests.py -e
</pre><p> You can pass a C++ class to specifiy that you want to generate tests only for a specific group or suite. </p><pre class="fragment">python processTests.py -e BasicTests
</pre><p> You can add a test ID to specify that you wan to run only a specific test in the suite: </p><pre class="fragment">python processTests.py -e BasicTests 4
</pre><p> Before filtering desc.txt by using a C++ class, you should (at least once) parse the full file without filtering.</p>
<p>The reason is that the cmake build is not aware of the filtering and will include some source files which are not needed when filtered out. So those files should at least be present to allow the compilation to proceed. They need to be generated at least once.</p>
<h2><a class="anchor" id="autotoc_md58"></a>
Generate the build system</h2>
<pre class="fragment">mkdir build
cd build
cmake -DCMAKE_PREFIX_PATH="path/to/tools" -DCMAKE_TOOLCHAIN_FILE=../../armcc.cmake -DARM_CPU="cortex-a5" -DPLATFORM="FVP" -DBENCHMARK=OFF -G "Unix Makefiles" ..
</pre><p> If BENCHMARK=ON is used, other options should be enabled to have better performances.</p>
<h2><a class="anchor" id="autotoc_md59"></a>
Build and run the tests</h2>
<p>Folder Output/BasicMaths should exist. For example, on Windows with ArmDS: </p><pre class="fragment">cd build
make VERBOSE=1
"C:\Program Files\ARM\Development Studio 2019.0\sw\models\bin\FVP_VE_Cortex-A5x1.exe" -a Testing  &gt; result.txt
</pre> <h2><a class="anchor" id="autotoc_md60"></a>
Parse the results</h2>
<pre class="fragment">cd ..
python processResult.py -e -r build\result.txt
</pre><p> -e option is needed if the mode -e was used with processTests because the output has a different format with or without -e option.</p>
<p>Some cycles are displayed with the test status (passed or failed). <b>Don't trust</b> those cycles for a benchmark.</p>
<p>At this point they are only an indication. The timing code will have to be tested and validated.</p>
<h2><a class="anchor" id="autotoc_md61"></a>
Generate summary statistics</h2>
<p>The parsing of the results may have generated some statistics in FullBenchmark folder.</p>
<p>The script summaryBench can parse those results and compute regression formula. </p><pre class="fragment">python summaryBench.py -r build\result.txt
</pre><p> The file result.txt must be placed inside the build folder for this script to work. Indeed, this script is using the path to result.txt to also find the file currentConfig.csv which has been created by the cmake command.</p>
<p>The Output.pickle file is used by default. It can be changed with -f option.</p>
<p>The output of this script may look like: </p><pre class="fragment">"ID","CATEGORY","Param C","Regression","MAX"
1,"DSP:ComplexMaths",1,"225.3749999999999 + A * 0.7083333333333606 + B * 0.7083333333333641 + A*B * 1.3749999999999876",260
</pre><p> Each test is uniquely identified with the CATEGORY and test ID (ID in the suite). The MAX column is the max of cycles computed for all values of A and B which were used for this benchmark.</p>
<h2><a class="anchor" id="autotoc_md62"></a>
Other tools</h2>
<p>To convert some benchmark to an older format. The PARAMS must be compatible between all suites which are children of AGroup </p><pre class="fragment">python convertToOld.py -e AGroup
</pre><p> Output.pickle is used by default. It can be changed with -f option.</p>
<p>To add a to sqlite3 databse: </p><pre class="fragment">python addToDB.py -e AGroup
</pre><p> Output.pickle is used by default. It can be changed with -f option.</p>
<p>The database must be created with createDb.sql before this script can be used.</p>
<h2><a class="anchor" id="autotoc_md63"></a>
Semihosting or FPGA mode</h2>
<p>The script processTests and processResult must be used with additional option -e for the FPGA (embedded mode)</p>
<p>testmain.cpp, in semihosting mode, must contain:</p>
<div class="fragment"><div class="line"><a class="code" href="class_client_1_1_semihosting.html">Client::Semihosting</a> io(<span class="stringliteral">&quot;../TestDesc.txt&quot;</span>,<span class="stringliteral">&quot;../Patterns&quot;</span>,<span class="stringliteral">&quot;../Output&quot;</span>);</div>
<div class="ttc" id="aclass_client_1_1_semihosting_html"><div class="ttname"><a href="class_client_1_1_semihosting.html">Client::Semihosting</a></div><div class="ttdef"><b>Definition:</b> Semihosting.h:49</div></div>
</div><!-- fragment --><p>In FPGA (embedded mode), this lne must be replaced with:</p>
<div class="fragment"><div class="line"><a class="code" href="class_client_1_1_f_p_g_a.html">Client::FPGA</a> io(testDesc,patterns);</div>
<div class="ttc" id="aclass_client_1_1_f_p_g_a_html"><div class="ttname"><a href="class_client_1_1_f_p_g_a.html">Client::FPGA</a></div><div class="ttdef"><b>Definition:</b> FPGA.h:48</div></div>
</div><!-- fragment --><p>testDesc and patterns are char* generated by the script processTests and containing the description of the tests to run and the test pattern samples to be used.</p>
<h2><a class="anchor" id="autotoc_md64"></a>
Dumping outputs</h2>
<p>To dump the output of the tests, the line</p>
<div class="fragment"><div class="line"><a class="code" href="class_client_1_1_i_o_runner.html">Client::IORunner</a> runner(&amp;io,&amp;mgr,Testing::kTestOnly);</div>
<div class="ttc" id="aclass_client_1_1_i_o_runner_html"><div class="ttname"><a href="class_client_1_1_i_o_runner.html">Client::IORunner</a></div><div class="ttdef"><b>Definition:</b> IORunner.h:36</div></div>
</div><!-- fragment --><p>Must be replaced by</p>
<div class="fragment"><div class="line"><a class="code" href="class_client_1_1_i_o_runner.html">Client::IORunner</a> runner(&amp;io,&amp;mgr,Testing::DumpOnly);</div>
</div><!-- fragment --><p>or</p>
<div class="fragment"><div class="line"><a class="code" href="class_client_1_1_i_o_runner.html">Client::IORunner</a> runner(&amp;io,&amp;mgr,Testing::kTestAndDump);</div>
</div><!-- fragment --><p>and of course, the test must contain a line to dump the outputs.</p>
<p>In DumpOnly mode, reference patterns are not loaded and the test assertions are "failing" but reporting passed.</p>
<p>So, if a test is in the middle of useful code, some part of the code will not execute.</p>
<p>As consequence, if you intend to use the DumpOnly mode, you must ensure that all test assertions are at the end of your test.</p>
<h1><a class="anchor" id="autotoc_md65"></a>
testmain.cpp</h1>
<p>To start the tests you need to:</p>
<ul>
<li>Allocate a memory manager</li>
<li>Choose IO (Semihosting or FPGA)</li>
<li>Instantiate a pattern manager (linking IO and memory)</li>
<li>Choose a test Runner (IORunner)</li>
<li>Instantiate the root object which is containing all tests</li>
<li>Apply the runner to the root object</li>
</ul>
<p>This is done in testmain.cpp.</p>
<h1><a class="anchor" id="autotoc_md66"></a>
HOW TO ADD NEW TESTS</h1>
<p>For a test suite MyClass, the scripts are generating an include file MyClass_decl.h</p>
<p>You should create another include Include/MyClass.h and another cpp file Source/MyClass.cpp in TEsting folder.</p>
<p>MyClass.h should contain:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;Test.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;Pattern.h&quot;</span></div>
<div class="line"><span class="keyword">class </span>MyClass:<span class="keyword">public</span> <a class="code" href="class_client_1_1_suite.html">Client::Suite</a></div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">public</span>:</div>
<div class="line">            MyClass(Testing::testID_t <span class="keywordtype">id</span>);</div>
<div class="line">            <span class="keywordtype">void</span> setUp(Testing::testID_t,std::vector&lt;Testing::param_t&gt;&amp; params,<a class="code" href="class_client_1_1_pattern_mgr.html">Client::PatternMgr</a> *mgr);</div>
<div class="line">            <span class="keywordtype">void</span> tearDown(Testing::testID_t,<a class="code" href="class_client_1_1_pattern_mgr.html">Client::PatternMgr</a> *mgr);</div>
<div class="line">        <span class="keyword">private</span>:</div>
<div class="line"><span class="preprocessor">            #include &quot;MyClass_decl.h&quot;</span></div>
<div class="line">            </div>
<div class="line">            <span class="comment">// Definitions of the patterns you have in the test description file</span></div>
<div class="line">            <span class="comment">// for this test suite</span></div>
<div class="line">            <a class="code" href="class_client_1_1_pattern.html">Client::Pattern&lt;float32_t&gt;</a> input1;</div>
<div class="line">            <a class="code" href="class_client_1_1_pattern.html">Client::Pattern&lt;float32_t&gt;</a> input2;</div>
<div class="line">            <a class="code" href="class_client_1_1_local_pattern.html">Client::LocalPattern&lt;float32_t&gt;</a> output;</div>
<div class="line">            <span class="comment">// Reference patterns are not loaded when we are in dump mode</span></div>
<div class="line">            <a class="code" href="class_client_1_1_ref_pattern.html">Client::RefPattern&lt;float32_t&gt;</a> ref;</div>
<div class="line">    };</div>
<div class="ttc" id="aclass_client_1_1_local_pattern_html"><div class="ttname"><a href="class_client_1_1_local_pattern.html">Client::LocalPattern&lt; float32_t &gt;</a></div></div>
<div class="ttc" id="aclass_client_1_1_pattern_html"><div class="ttname"><a href="class_client_1_1_pattern.html">Client::Pattern&lt; float32_t &gt;</a></div></div>
<div class="ttc" id="aclass_client_1_1_pattern_mgr_html"><div class="ttname"><a href="class_client_1_1_pattern_mgr.html">Client::PatternMgr</a></div><div class="ttdef"><b>Definition:</b> Test.h:397</div></div>
<div class="ttc" id="aclass_client_1_1_ref_pattern_html"><div class="ttname"><a href="class_client_1_1_ref_pattern.html">Client::RefPattern&lt; float32_t &gt;</a></div></div>
<div class="ttc" id="aclass_client_1_1_suite_html"><div class="ttname"><a href="class_client_1_1_suite.html">Client::Suite</a></div><div class="ttdef"><b>Definition:</b> Test.h:538</div></div>
</div><!-- fragment --><p>Then, you should provide an implementation of setUp, tearDown and of course your tests.</p>
<p>So, MyClass.cpp could be:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;MyClass.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;Error.h&quot;</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Implementation of your test</span></div>
<div class="line">    <span class="keywordtype">void</span> MyClass::test_add_f32()</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Ptr to input patterns, references and output. </span></div>
<div class="line">        <span class="comment">// Input and references have been loaded in setUp</span></div>
<div class="line">        <span class="keyword">const</span> float32_t *inp1=input1.ptr();</div>
<div class="line">        <span class="keyword">const</span> float32_t *inp2=input2.ptr();</div>
<div class="line">        float32_t *refp=ref.ptr();</div>
<div class="line">        float32_t *outp=output.ptr();</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Execution of the tests</span></div>
<div class="line">        <a class="code" href="group___basic_add.html#gabfef1e86e458314a61f4baa441d9765e">arm_add_f32</a>(inp1,inp2,outp,input1.nbSamples());</div>
<div class="line">        </div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Testing.</span></div>
<div class="line">        <span class="comment">// Warning : in case of benchmarking this will be taken into account in the</span></div>
<div class="line">        <span class="comment">// benchmark. So a benchmark should not contain tests.</span></div>
<div class="line">        ASSERT_NEAR_EQ(ref,output,(<span class="keywordtype">float</span>)1e-6);</div>
<div class="line"> </div>
<div class="line">    } </div>
<div class="ttc" id="agroup___basic_add_html_gabfef1e86e458314a61f4baa441d9765e"><div class="ttname"><a href="group___basic_add.html#gabfef1e86e458314a61f4baa441d9765e">arm_add_f32</a></div><div class="ttdeci">void arm_add_f32(const float32_t *pSrcA, const float32_t *pSrcB, float32_t *pDst, uint32_t blockSize)</div><div class="ttdoc">Floating-point vector addition.</div><div class="ttdef"><b>Definition:</b> arm_add_f32.c:114</div></div>
</div><!-- fragment --><p>Warning : in case of a benchmark the xxx.ptr() function calls should be done in the setup function because they have an overhead.</p>
<p>If you use regression formula, this overhead will modify the intercept but the coefficient of highest degree should not be changed.</p>
<p>Then setUp should load the patterns:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> MyClass::setUp(Testing::testID_t <span class="keywordtype">id</span>,std::vector&lt;Testing::param_t&gt;&amp; params,<a class="code" href="class_client_1_1_pattern_mgr.html">Client::PatternMgr</a> *mgr)</div>
<div class="line">    {</div>
<div class="line">      </div>
<div class="line">       Testing::nbSamples_t nb=MAX_NB_SAMPLES; </div>
<div class="line"> </div>
<div class="line">       <span class="comment">// We can load different pattern or length according to the test ID</span></div>
<div class="line">       <span class="keywordflow">switch</span>(<span class="keywordtype">id</span>)</div>
<div class="line">       {</div>
<div class="line">        <span class="keywordflow">case</span> MyClass::TEST_ADD_F32_1:</div>
<div class="line">          nb = 3;</div>
<div class="line">          ref.reload(MyClass::REF_ADD_F32_ID,mgr,nb);</div>
<div class="line">          <span class="keywordflow">break</span>;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">      input1.reload(BasicTests::INPUT1_F32_ID,mgr,nb);</div>
<div class="line">      input2.reload(BasicTests::INPUT2_F32_ID,mgr,nb);</div>
<div class="line"> </div>
<div class="line">      output.create(input1.nbSamples(),BasicTests::OUT_SAMPLES_F32_ID,mgr);</div>
<div class="line">   }</div>
</div><!-- fragment --><p>In tearDown we have to clean the test. No need to free the buffer since the memory manager will do it in an automatic way. But if other allocations were done outside of the memory manager, then the clean up should be done here.</p>
<p>It is also here that you specify what you want to dump if you're in dump mode.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> MyClass::tearDown(Testing::testID_t <span class="keywordtype">id</span>,<a class="code" href="class_client_1_1_pattern_mgr.html">Client::PatternMgr</a> *mgr)</div>
<div class="line">{</div>
<div class="line">    output.dump(mgr);</div>
<div class="line">}</div>
</div><!-- fragment --> <h1><a class="anchor" id="autotoc_md67"></a>
Benchmarks and database</h1>
<h2><a class="anchor" id="autotoc_md68"></a>
Creating and filling the databases</h2>
<p>To add a to sqlite3 databse: </p><pre class="fragment">python addToDB.py AGroup
</pre><p> Output.pickle is used by default. It can be changed with -f option.</p>
<p>AGroup should be the class name of a Group in the desc.txt</p>
<p>The suite in this Group should be compatible and have the same parameters.</p>
<p>For instance, we have a BasicBenchmarks group is desc.txt This group is containing the suites <a class="el" href="class_basic_maths_benchmarks_f32.html">BasicMathsBenchmarksF32</a>, <a class="el" href="class_basic_maths_benchmarks_q31.html">BasicMathsBenchmarksQ31</a>, BasicMathsBenchmarks15 and <a class="el" href="class_basic_maths_benchmarks_q7.html">BasicMathsBenchmarksQ7</a>.</p>
<p>Each suite is defining the same parameters : NB.</p>
<p>If you use: </p><pre class="fragment">python addToDB.py BasicBenchmarks
</pre><p> Output.pickle is used by default. It can be changed with -f option.</p>
<p>A table BasicBenchmarks will be create and the benchmarks result for F32, Q31, Q15 and Q7 will be added to this table.</p>
<p>But, if you do: </p><pre class="fragment">python addToDB.py BasicMathsBenchmarksF32
</pre><p> The a table <a class="el" href="class_basic_maths_benchmarks_f32.html">BasicMathsBenchmarksF32</a> will be created which is probably not what you want since the table is containing a type column (f32,q31, q15, q7)</p>
<p>The script addToRegDB.py is working on the same principle but using the regression csv to fill a regression database.</p>
<p>To create an empty database you can use (for default database) </p><pre class="fragment">sqlite3.exe bench.db &lt; createDb.sql 
</pre><p> And for regression database: </p><pre class="fragment">sqlite3.exe reg.db &lt; createDb.sql 
</pre><p> Since the python scripts are using bench.db and reg.db as default names for the databases.</p>
<h2><a class="anchor" id="autotoc_md69"></a>
Processing the database</h2>
<p>Database schema (defined in createDb.sql) is creating several columns for the fields which are common to lot of rows like core, compiler, compiler version, datatype etc ...</p>
<p>Like that it is easier to change the name of this additional information and it makes the database smaller.</p>
<p>But then it means that to display the tables in a readable format by the user, some joins are needed.</p>
<p>examples.sql and diff.sql are showing some examples.</p>
<p>examples.sql : how to do simple queries and join with the configuration columns to get a readable format.</p>
<p>diff.sql : How to compute a performance ratio (max cycle and regression) based on a reference core (which could be extended to a reference configuration if needed).</p>
<h1><a class="anchor" id="autotoc_md70"></a>
HOW TO EXTEND IT</h1>
<h1><a class="anchor" id="autotoc_md71"></a>
FLOAT16 support</h1>
<p>On Arm AC5 compiler __fp16 type (float16_t in CMSIS-DSP) can't be used as argument or return value of a function.</p>
<p>Pointer to _fp16 arrays are allowed.</p>
<p>In CMSIS-DSP, we want to keep the possibility of having float16_t as an argument.</p>
<p>As consequences,</p>
<ul>
<li>the functions using float16_t in the API won't be supported by AC5 compiler.</li>
<li>The correspondingfloat16_t tests are put in a different test file desc_f16.txt</li>
<li>Code for those float16_t test is not built when ac5.cmake toolchain is used</li>
<li>BasicMath cmake has been modified to show hot to avoid including float16 code when building with ac5.cmake toolchain</li>
</ul>
<p>In current example, we assume all float16_t code and tests are not supported by AC5 just to show how the cmake must be modified.</p>
<p>When more float16_t code is added to the CMSIS-DSP, this will be refined with a better separation. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
