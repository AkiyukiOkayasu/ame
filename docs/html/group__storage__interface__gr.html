<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AME: Storage Interface</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">AME
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__storage__interface__gr.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Storage Interface</div>  </div>
</div><!--header-->
<div class="contents">

<p>Driver API for Storage Device Interface (Driver_Storage.h)  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group___storage_driver_functions"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___storage_driver_functions.html">Use of Storage APIs</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group___sample_use_of_storage_driver"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sample_use_of_storage_driver.html">Sample Use of Storage Driver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_r_m___s_t_o_r_a_g_e___b_l_o_c_k___a_t_t_r_i_b_u_t_e_s.html">ARM_STORAGE_BLOCK_ATTRIBUTES</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_r_m___s_t_o_r_a_g_e___b_l_o_c_k.html">ARM_STORAGE_BLOCK</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_r_m___s_t_o_r_a_g_e___i_n_f_o.html">ARM_STORAGE_INFO</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_r_m___d_r_i_v_e_r___s_t_o_r_a_g_e.html">ARM_DRIVER_STORAGE</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_r_m___s_t_o_r_a_g_e___c_a_p_a_b_i_l_i_t_i_e_s.html">ARM_STORAGE_CAPABILITIES</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_r_m___s_t_o_r_a_g_e___s_t_a_t_u_s.html">ARM_STORAGE_STATUS</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga4b290224fea782e6d2ad06f541b28a98"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__storage__interface__gr.html#ga4b290224fea782e6d2ad06f541b28a98">ARM_Storage_Callback_t</a>) (int32_t status, ARM_STORAGE_OPERATION operation)</td></tr>
<tr class="separator:ga4b290224fea782e6d2ad06f541b28a98"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaf28193431b1a2ee64b22bfb36aed27e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_a_r_m___d_r_i_v_e_r___v_e_r_s_i_o_n.html">ARM_DRIVER_VERSION</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__storage__interface__gr.html#gaf28193431b1a2ee64b22bfb36aed27e3">ARM_Storage_GetVersion</a> (void)</td></tr>
<tr class="memdesc:gaf28193431b1a2ee64b22bfb36aed27e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get driver version.  <a href="group__storage__interface__gr.html#gaf28193431b1a2ee64b22bfb36aed27e3">More...</a><br /></td></tr>
<tr class="separator:gaf28193431b1a2ee64b22bfb36aed27e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8378b3901dfe76d8f31728a50e10dae2"><td class="memItemLeft" align="right" valign="top">ARM_STOR_CAPABILITIES&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__storage__interface__gr.html#ga8378b3901dfe76d8f31728a50e10dae2">ARM_Storage_GetCapabilities</a> (void)</td></tr>
<tr class="memdesc:ga8378b3901dfe76d8f31728a50e10dae2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get driver capabilities.  <a href="group__storage__interface__gr.html#ga8378b3901dfe76d8f31728a50e10dae2">More...</a><br /></td></tr>
<tr class="separator:ga8378b3901dfe76d8f31728a50e10dae2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc5dc090a35ac16caff8957030eaa174"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__storage__interface__gr.html#gacc5dc090a35ac16caff8957030eaa174">ARM_Storage_Initialize</a> (<a class="el" href="group__storage__interface__gr.html#ga4b290224fea782e6d2ad06f541b28a98">ARM_Storage_Callback_t</a> callback)</td></tr>
<tr class="memdesc:gacc5dc090a35ac16caff8957030eaa174"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the Storage interface.  <a href="group__storage__interface__gr.html#gacc5dc090a35ac16caff8957030eaa174">More...</a><br /></td></tr>
<tr class="separator:gacc5dc090a35ac16caff8957030eaa174"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d14b15ddcda2836c6e3c1d0b5e60dca"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__storage__interface__gr.html#ga1d14b15ddcda2836c6e3c1d0b5e60dca">ARM_Storage_Uninitialize</a> (void)</td></tr>
<tr class="memdesc:ga1d14b15ddcda2836c6e3c1d0b5e60dca"><td class="mdescLeft">&#160;</td><td class="mdescRight">De-initialize the Storage Interface.  <a href="group__storage__interface__gr.html#ga1d14b15ddcda2836c6e3c1d0b5e60dca">More...</a><br /></td></tr>
<tr class="separator:ga1d14b15ddcda2836c6e3c1d0b5e60dca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga979a2484bf05b2986de95a5d98307d54"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__storage__interface__gr.html#ga979a2484bf05b2986de95a5d98307d54">ARM_Storage_PowerControl</a> (ARM_POWER_STATE state)</td></tr>
<tr class="memdesc:ga979a2484bf05b2986de95a5d98307d54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control the Storage interface power.  <a href="group__storage__interface__gr.html#ga979a2484bf05b2986de95a5d98307d54">More...</a><br /></td></tr>
<tr class="separator:ga979a2484bf05b2986de95a5d98307d54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabaa24553c165add98020434c980b3ab4"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__storage__interface__gr.html#gabaa24553c165add98020434c980b3ab4">ARM_Storage_ReadData</a> (uint64_t addr, void *data, uint32_t size)</td></tr>
<tr class="memdesc:gabaa24553c165add98020434c980b3ab4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data from Storage.  <a href="group__storage__interface__gr.html#gabaa24553c165add98020434c980b3ab4">More...</a><br /></td></tr>
<tr class="separator:gabaa24553c165add98020434c980b3ab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd20d561854c06918b0515b6c1bba230"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__storage__interface__gr.html#gabd20d561854c06918b0515b6c1bba230">ARM_Storage_ProgramData</a> (uint64_t addr, const void *data, uint32_t size)</td></tr>
<tr class="memdesc:gabd20d561854c06918b0515b6c1bba230"><td class="mdescLeft">&#160;</td><td class="mdescRight">Program data to Storage.  <a href="group__storage__interface__gr.html#gabd20d561854c06918b0515b6c1bba230">More...</a><br /></td></tr>
<tr class="separator:gabd20d561854c06918b0515b6c1bba230"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaceef4851d9181cce65c8b2d05f4429bc"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__storage__interface__gr.html#gaceef4851d9181cce65c8b2d05f4429bc">ARM_Storage_Erase</a> (uint64_t addr, uint32_t size)</td></tr>
<tr class="memdesc:gaceef4851d9181cce65c8b2d05f4429bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase Storage range.  <a href="group__storage__interface__gr.html#gaceef4851d9181cce65c8b2d05f4429bc">More...</a><br /></td></tr>
<tr class="separator:gaceef4851d9181cce65c8b2d05f4429bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04e77387a3c628d6fc661e82f7daddaa"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__storage__interface__gr.html#ga04e77387a3c628d6fc661e82f7daddaa">ARM_Storage_EraseAll</a> (void)</td></tr>
<tr class="memdesc:ga04e77387a3c628d6fc661e82f7daddaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase complete Storage.  <a href="group__storage__interface__gr.html#ga04e77387a3c628d6fc661e82f7daddaa">More...</a><br /></td></tr>
<tr class="separator:ga04e77387a3c628d6fc661e82f7daddaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29e7bfe78f41abb16973bdb4e0188a20"><td class="memItemLeft" align="right" valign="top">ARM_Storage_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__storage__interface__gr.html#ga29e7bfe78f41abb16973bdb4e0188a20">ARM_Storage_GetStatus</a> (void)</td></tr>
<tr class="memdesc:ga29e7bfe78f41abb16973bdb4e0188a20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Storage status.  <a href="group__storage__interface__gr.html#ga29e7bfe78f41abb16973bdb4e0188a20">More...</a><br /></td></tr>
<tr class="separator:ga29e7bfe78f41abb16973bdb4e0188a20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad557e8e6e33cd4528d398ecf4dddc747"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__storage__interface__gr.html#gad557e8e6e33cd4528d398ecf4dddc747">ARM_Storage_GetInfo</a> (<a class="el" href="struct_a_r_m___s_t_o_r_a_g_e___i_n_f_o.html">ARM_STORAGE_INFO</a> *info)</td></tr>
<tr class="memdesc:gad557e8e6e33cd4528d398ecf4dddc747"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Storage information.  <a href="group__storage__interface__gr.html#gad557e8e6e33cd4528d398ecf4dddc747">More...</a><br /></td></tr>
<tr class="separator:gad557e8e6e33cd4528d398ecf4dddc747"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a1934750a51c74b8b0fea52588a3b9a"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__storage__interface__gr.html#ga5a1934750a51c74b8b0fea52588a3b9a">ARM_Storage_ResolveAddress</a> (uint64_t addr)</td></tr>
<tr class="memdesc:ga5a1934750a51c74b8b0fea52588a3b9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resolve an address relative to the storage controller into a memory address.  <a href="group__storage__interface__gr.html#ga5a1934750a51c74b8b0fea52588a3b9a">More...</a><br /></td></tr>
<tr class="separator:ga5a1934750a51c74b8b0fea52588a3b9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad318f8cb38626cbeea1fcf36a0977c44"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__storage__interface__gr.html#gad318f8cb38626cbeea1fcf36a0977c44">ARM_Storage_GetNextBlock</a> (const <a class="el" href="struct_a_r_m___s_t_o_r_a_g_e___b_l_o_c_k.html">ARM_STORAGE_BLOCK</a> *prev_block, <a class="el" href="struct_a_r_m___s_t_o_r_a_g_e___b_l_o_c_k.html">ARM_STORAGE_BLOCK</a> *next_block)</td></tr>
<tr class="memdesc:gad318f8cb38626cbeea1fcf36a0977c44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advance to the successor of the current block (iterator).  <a href="group__storage__interface__gr.html#gad318f8cb38626cbeea1fcf36a0977c44">More...</a><br /></td></tr>
<tr class="separator:gad318f8cb38626cbeea1fcf36a0977c44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5fe9d27ce8afe65124dec62566114073"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__storage__interface__gr.html#ga5fe9d27ce8afe65124dec62566114073">ARM_Storage_GetBlock</a> (uint64_t addr, <a class="el" href="struct_a_r_m___s_t_o_r_a_g_e___b_l_o_c_k.html">ARM_STORAGE_BLOCK</a> *block)</td></tr>
<tr class="memdesc:ga5fe9d27ce8afe65124dec62566114073"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the storage block (iterator) encompassing a given storage address.  <a href="group__storage__interface__gr.html#ga5fe9d27ce8afe65124dec62566114073">More...</a><br /></td></tr>
<tr class="separator:ga5fe9d27ce8afe65124dec62566114073"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Driver API for Storage Device Interface (Driver_Storage.h) </p>
<p>This is an abstraction for a storage controller. It offers an interface to access an address space of storage locations, comprising APIs for initialization, erase, access, program, and status-fetch operations. It also offers APIs to iterate over the available Storage Blocks (<a class="el" href="struct_a_r_m___s_t_o_r_a_g_e___b_l_o_c_k.html">ARM_STORAGE_BLOCK</a>), allowing the discovery of block attributes such as write/erase granularities. Using the Storage abstraction, it becomes possible to write generic algorithms, such as block copy, to operate on any conforming storage device.</p>
<dl class="section note"><dt>Note</dt><dd>The storage abstraction layer is not responsible for storage management. Algorithms such as block-allocation, wear-leveling, erase-before-write and other storage-management policies are the responsibility of modules external to the storage abstraction layer. In essence, the storage interface is the lowest abstraction upon which block management policies can be implemented.</dd></dl>
<p>Here's a picture to help locate the storage abstraction in the software stack. The part below the box labeled 'Storage abstraction layer' is implemented by a storage driver.</p>
<div class="image">
<img src="storage_sw_stack.png" alt=""/>
</div>
<p><b>Storage API</b></p>
<p>The following header files define the Application Programming Interface (API) for the Flash interface:</p><ul>
<li><b>Driver_Storage.h</b> : Driver API for Storage Device Interface</li>
</ul>
<p><b>Driver Functions</b></p>
<p>The driver functions are published in the access struct as explained in <a class="el" href="group___storage_driver_functions.html">Use of Storage APIs</a></p><ul>
<li><a class="el" href="struct_a_r_m___d_r_i_v_e_r___s_t_o_r_a_g_e.html">ARM_DRIVER_STORAGE</a> : access struct for Storage driver functions</li>
</ul>
<p>A sample use for the driver can be found at: <a class="el" href="group___sample_use_of_storage_driver.html">Sample Use of Storage Driver</a> </p>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga4b290224fea782e6d2ad06f541b28a98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4b290224fea782e6d2ad06f541b28a98">&#9670;&nbsp;</a></span>ARM_Storage_Callback_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ARM_Storage_Callback_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Provides the typedef for the callback function <a class="el" href="group__storage__interface__gr.html#ga4b290224fea782e6d2ad06f541b28a98">ARM_Storage_Callback_t</a>.</p>
<p>Provides the typedef for the callback function <a class="el" href="group__storage__interface__gr.html#ga4b290224fea782e6d2ad06f541b28a98">ARM_Storage_Callback_t</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">status</td><td>A code to indicate the status of the completed operation. For data transfer operations, the status field is overloaded in case of success to return the count of bytes successfully transferred; this can be done safely because error codes are negative values.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">operation</td><td>The command op-code. This value isn't essential, but it is expected that this information could be a quick and useful filter for the handler.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Parameter for:</b></p><ul>
<li><a class="el" href="group__storage__interface__gr.html#gacc5dc090a35ac16caff8957030eaa174">ARM_Storage_Initialize</a> </li>
</ul>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaceef4851d9181cce65c8b2d05f4429bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaceef4851d9181cce65c8b2d05f4429bc">&#9670;&nbsp;</a></span>ARM_Storage_Erase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ARM_Storage_Erase </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erase Storage range. </p>
<p>This function erases a range of storage specified by [addr, addr + size). Both 'addr' and 'addr + size' should align with the 'erase_unit'(s) of the respective owning storage block(s) (see <a class="el" href="struct_a_r_m___s_t_o_r_a_g_e___b_l_o_c_k.html">ARM_STORAGE_BLOCK</a> and <a class="el" href="struct_a_r_m___s_t_o_r_a_g_e___b_l_o_c_k___a_t_t_r_i_b_u_t_e_s.html">ARM_STORAGE_BLOCK_ATTRIBUTES</a>). The range to be erased will have its contents returned to the un-programmed state&ndash; i.e. to ARM_STORAGE_INFO::erased_value, which is usually 1 to indicate the pattern of all ones: 0xFF.</p>
<dl class="section note"><dt>Note</dt><dd>This API may execute asynchronously if ARM_STORAGE_CAPABILITIES::asynchronous_ops is set. Asynchronous execution is optional even if 'asynchronous_ops' is set.</dd>
<dd>
Erase() may return a smaller (positive) value than the size of the requested range. The returned value indicates the actual number of bytes erased. It is the caller's responsibility to follow up with an appropriate request to complete the operation.</dd>
<dd>
in the case of a failed erase (except when ARM_DRIVER_ERROR_PARAMETER, ARM_STORAGE_ERROR_PROTECTED, or ARM_STORAGE_ERROR_NOT_ERASABLE is returned synchronously), the requested range should be assumed to be in an unknown state. The previous contents may not be retained.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>This is the start-address of the range to be erased. It must start at an 'erase_unit' boundary of the underlying block. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Size (in bytes) of the range to be erased. 'addr + size' must be aligned with the 'erase_unit' of the underlying block. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the range to be erased doesn't align with the erase_units of the respective start and end blocks, ARM_DRIVER_ERROR_PARAMETER is returned. If any part of the range is protected, ARM_STORAGE_ERROR_PROTECTED is returned. If any part of the range is not erasable, ARM_STORAGE_ERROR_NOT_ERASABLE is returned. All such sanity-check failures result in the error code being returned synchronously and the storage bytes within the range remain unaffected. Otherwise the function executes in the following ways: If asynchronous activity is launched, an invocation returns ARM_DRIVER_OK, and the caller can expect to receive a callback in the future with the number of successfully erased bytes passed in as the 'status' parameter. In the case of synchronous execution, control returns after completion with a positive erase-count. Return values less than ARM_DRIVER_OK (0) signify errors. </dd></dl>

</div>
</div>
<a id="ga04e77387a3c628d6fc661e82f7daddaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga04e77387a3c628d6fc661e82f7daddaa">&#9670;&nbsp;</a></span>ARM_Storage_EraseAll()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ARM_Storage_EraseAll </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erase complete Storage. </p>
<p>This optional function erases the complete device. If the device does not support global erase then the function returns the error value <a class="el" href="group__execution__status.html#ga2efa59e480d82697795439220e6884e4">ARM_DRIVER_ERROR_UNSUPPORTED</a>. The data field <em>'erase_all'</em> = \token{1} of the structure <a class="el" href="struct_a_r_m___s_t_o_r_a_g_e___c_a_p_a_b_i_l_i_t_i_e_s.html">ARM_STORAGE_CAPABILITIES</a> encodes that <a class="el" href="group__storage__interface__gr.html#ga04e77387a3c628d6fc661e82f7daddaa">ARM_Storage_EraseAll</a> is supported.</p>
<dl class="section note"><dt>Note</dt><dd>This API may execute asynchronously if ARM_STORAGE_CAPABILITIES::asynchronous_ops is set. Asynchronous execution is optional even if 'asynchronous_ops' is set.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>If any part of the storage range is protected, ARM_STORAGE_ERROR_PROTECTED is returned. If any part of the storage range is not erasable, ARM_STORAGE_ERROR_NOT_ERASABLE is returned. All such sanity-check failures result in the error code being returned synchronously and the storage bytes within the range remain unaffected. Otherwise the function executes in the following ways: If asynchronous activity is launched, an invocation returns ARM_DRIVER_OK, and the caller can expect to receive a callback in the future with ARM_DRIVER_OK passed in as the 'status' parameter. In the case of synchronous execution, control returns after completion with a value of 1. Return values less than ARM_DRIVER_OK (0) signify errors. </dd></dl>

</div>
</div>
<a id="ga5fe9d27ce8afe65124dec62566114073"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5fe9d27ce8afe65124dec62566114073">&#9670;&nbsp;</a></span>ARM_Storage_GetBlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ARM_Storage_GetBlock </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_a_r_m___s_t_o_r_a_g_e___b_l_o_c_k.html">ARM_STORAGE_BLOCK</a> *&#160;</td>
          <td class="paramname"><em>block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the storage block (iterator) encompassing a given storage address. </p>
<dl class="section note"><dt>Note</dt><dd>This API returns synchronously&ndash;it does not result in an invocation of a completion callback.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>Storage address in bytes. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">block</td><td>A caller-owned buffer large enough to be filled in with the <a class="el" href="struct_a_r_m___s_t_o_r_a_g_e___b_l_o_c_k.html">ARM_STORAGE_BLOCK</a> encapsulating the given address. This value can also be passed in as NULL if the caller isn't interested in populating a buffer with the block, if the caller only wishes to establish the presence of a containing storage block. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ARM_DRIVER_OK if a containing storage-block is found. In this case, if block is non-NULL, the buffer pointed to by it is populated with the contents of the storage block, i.e. if block is valid and a block is found, ARM_STORAGE_VALID_BLOCK(block) would return true following this call. If there is no storage block containing the given offset, or in case the driver is unable to resolve an address to a storage-block, an error (negative) value is returned and an invalid StorageBlock is populated into the supplied buffer. </dd></dl>

</div>
</div>
<a id="ga8378b3901dfe76d8f31728a50e10dae2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8378b3901dfe76d8f31728a50e10dae2">&#9670;&nbsp;</a></span>ARM_Storage_GetCapabilities()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_a_r_m___s_t_o_r_a_g_e___c_a_p_a_b_i_l_i_t_i_e_s.html">ARM_STORAGE_CAPABILITIES</a> ARM_Storage_GetCapabilities </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get driver capabilities. </p>
<p>The function <b>ARM_Storage_GetCapabilities</b> returns information about capabilities in this driver implementation. The data fields of the struct <a class="el" href="struct_a_r_m___s_t_o_r_a_g_e___c_a_p_a_b_i_l_i_t_i_e_s.html">ARM_STORAGE_CAPABILITIES</a> encode various capabilities, for example if the device is able to execute operations asynchronously.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keyword">extern</span> <a class="code" href="struct_a_r_m___d_r_i_v_e_r___s_t_o_r_a_g_e.html">ARM_DRIVER_STORAGE</a> *drv_info;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> read_capabilities (<span class="keywordtype">void</span>)  {</div>
<div class="line">  <a class="code" href="struct_a_r_m___s_t_o_r_a_g_e___c_a_p_a_b_i_l_i_t_i_e_s.html">ARM_STORAGE_CAPABILITIES</a> drv_capabilities;</div>
<div class="line"> </div>
<div class="line">  drv_capabilities = drv_info-&gt;GetCapabilities ();</div>
<div class="line">  <span class="comment">// interrogate capabilities</span></div>
<div class="line"> </div>
<div class="line">}</div>
<div class="ttc" id="astruct_a_r_m___d_r_i_v_e_r___s_t_o_r_a_g_e_html"><div class="ttname"><a href="struct_a_r_m___d_r_i_v_e_r___s_t_o_r_a_g_e.html">ARM_DRIVER_STORAGE</a></div></div>
<div class="ttc" id="astruct_a_r_m___s_t_o_r_a_g_e___c_a_p_a_b_i_l_i_t_i_e_s_html"><div class="ttname"><a href="struct_a_r_m___s_t_o_r_a_g_e___c_a_p_a_b_i_l_i_t_i_e_s.html">ARM_STORAGE_CAPABILITIES</a></div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>This API returns synchronously&ndash;it does not result in an invocation of a completion callback.</dd>
<dd>
The function GetCapabilities() can be called any time to obtain the required information from the driver (even before initialization). It always returns the same information.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="struct_a_r_m___s_t_o_r_a_g_e___c_a_p_a_b_i_l_i_t_i_e_s.html">ARM_STORAGE_CAPABILITIES</a> </dd></dl>

</div>
</div>
<a id="gad557e8e6e33cd4528d398ecf4dddc747"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad557e8e6e33cd4528d398ecf4dddc747">&#9670;&nbsp;</a></span>ARM_Storage_GetInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ARM_Storage_GetInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_a_r_m___s_t_o_r_a_g_e___i_n_f_o.html">ARM_STORAGE_INFO</a> *&#160;</td>
          <td class="paramname"><em>info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get Storage information. </p>
<p>Get information about the Storage device; stored in the structure <a class="el" href="struct_a_r_m___s_t_o_r_a_g_e___i_n_f_o.html">ARM_STORAGE_INFO</a>.</p>
<dl class="section note"><dt>Note</dt><dd>It is the caller's responsibility to ensure that the buffer passed in is able to be initialized with a <a class="el" href="struct_a_r_m___s_t_o_r_a_g_e___i_n_f_o.html">ARM_STORAGE_INFO</a>.</dd>
<dd>
This API returns synchronously&ndash;it does not result in an invocation of a completion callback.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">info</td><td>A caller-supplied buffer capable of being filled in with an <a class="el" href="struct_a_r_m___s_t_o_r_a_g_e___i_n_f_o.html">ARM_STORAGE_INFO</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ARM_DRIVER_OK if a <a class="el" href="struct_a_r_m___s_t_o_r_a_g_e___i_n_f_o.html">ARM_STORAGE_INFO</a> structure containing top level metadata about the storage controller is filled into the supplied buffer, else an appropriate error value. </dd></dl>

</div>
</div>
<a id="gad318f8cb38626cbeea1fcf36a0977c44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad318f8cb38626cbeea1fcf36a0977c44">&#9670;&nbsp;</a></span>ARM_Storage_GetNextBlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ARM_Storage_GetNextBlock </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_a_r_m___s_t_o_r_a_g_e___b_l_o_c_k.html">ARM_STORAGE_BLOCK</a> *&#160;</td>
          <td class="paramname"><em>prev_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_a_r_m___s_t_o_r_a_g_e___b_l_o_c_k.html">ARM_STORAGE_BLOCK</a> *&#160;</td>
          <td class="paramname"><em>next_block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Advance to the successor of the current block (iterator). </p>
<p>This helper function fetches (an iterator to) the next block (or the first block if 'prev_block' is passed in as NULL). In the failure case, a terminating, invalid block iterator is filled into the out parameter: 'next_block'. In combination with ARM_STORAGE_VALID_BLOCK, it can be used to iterate over the sequence of blocks within the storage map:</p>
<div class="fragment"><div class="line"><a class="code" href="struct_a_r_m___s_t_o_r_a_g_e___b_l_o_c_k.html">ARM_STORAGE_BLOCK</a> block;</div>
<div class="line"><span class="keywordflow">for</span> (drv-&gt;GetNextBlock(NULL, &amp;block); ARM_STORAGE_VALID_BLOCK(&amp;block); drv-&gt;GetNextBlock(&amp;block, &amp;block)) {</div>
<div class="line">    <span class="comment">// make use of block</span></div>
<div class="line">}</div>
<div class="ttc" id="astruct_a_r_m___s_t_o_r_a_g_e___b_l_o_c_k_html"><div class="ttname"><a href="struct_a_r_m___s_t_o_r_a_g_e___b_l_o_c_k.html">ARM_STORAGE_BLOCK</a></div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>This API returns synchronously&ndash;it does not result in an invocation of a completion callback.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">prev_block</td><td>An existing block (iterator) within the same storage controller. The memory buffer holding this block is owned by the caller. This pointer may be NULL; if so, the invocation fills in the first block into the out parameter: 'next_block'. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">next_block</td><td>A caller-owned buffer large enough to be filled in with the following <a class="el" href="struct_a_r_m___s_t_o_r_a_g_e___b_l_o_c_k.html">ARM_STORAGE_BLOCK</a>. It is legal to provide the same buffer using 'next_block' as was passed in with 'prev_block'. It is also legal to pass a NULL into this parameter if the caller isn't interested in populating a buffer with the next block, i.e. if the caller only wishes to establish the presence of a next block. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ARM_DRIVER_OK if a valid next block is found (or first block, if prev_block is passed as NULL); upon successful operation, the contents of the next (or first) block are filled into the buffer pointed to by the parameter 'next_block' and ARM_STORAGE_VALID_BLOCK(next_block) is guaranteed to be true. Upon reaching the end of the sequence of blocks (iterators), or in case the driver is unable to fetch information about the next (or first) block, an error (negative) value is returned and an invalid StorageBlock is populated into the supplied buffer. If prev_block is NULL, the first block is returned. </dd></dl>

</div>
</div>
<a id="ga29e7bfe78f41abb16973bdb4e0188a20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga29e7bfe78f41abb16973bdb4e0188a20">&#9670;&nbsp;</a></span>ARM_Storage_GetStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_a_r_m___s_t_o_r_a_g_e___s_t_a_t_u_s.html">ARM_STORAGE_STATUS</a> ARM_Storage_GetStatus </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get Storage status. </p>
<p>Get the status of the current (or previous) command executed by the storage controller; stored in the structure <a class="el" href="struct_a_r_m___s_t_o_r_a_g_e___s_t_a_t_u_s.html">ARM_STORAGE_STATUS</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This API returns synchronously&ndash;it does not result in an invocation of a completion callback.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Storage status <a class="el" href="struct_a_r_m___s_t_o_r_a_g_e___s_t_a_t_u_s.html">ARM_STORAGE_STATUS</a> </dd></dl>

</div>
</div>
<a id="gaf28193431b1a2ee64b22bfb36aed27e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf28193431b1a2ee64b22bfb36aed27e3">&#9670;&nbsp;</a></span>ARM_Storage_GetVersion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_a_r_m___d_r_i_v_e_r___v_e_r_s_i_o_n.html">ARM_DRIVER_VERSION</a> ARM_Storage_GetVersion </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get driver version. </p>
<p>The function <b>ARM_Storage_GetVersion</b> returns version information of the driver implementation in <a class="el" href="struct_a_r_m___d_r_i_v_e_r___v_e_r_s_i_o_n.html">ARM_DRIVER_VERSION</a>.</p><ul>
<li>API version is the version of the CMSIS-Driver specification used to implement this driver.</li>
<li>Driver version is source code version of the actual driver implementation.</li>
</ul>
<p>Example: </p><div class="fragment"><div class="line"><span class="keyword">extern</span> <a class="code" href="struct_a_r_m___d_r_i_v_e_r___s_t_o_r_a_g_e.html">ARM_DRIVER_STORAGE</a> *drv_info;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> read_version (<span class="keywordtype">void</span>)  {</div>
<div class="line">  <a class="code" href="struct_a_r_m___d_r_i_v_e_r___v_e_r_s_i_o_n.html">ARM_DRIVER_VERSION</a>  version;</div>
<div class="line"> </div>
<div class="line">  version = drv_info-&gt;GetVersion ();</div>
<div class="line">  <span class="keywordflow">if</span> (version.api &lt; 0x10A)   {      <span class="comment">// requires at minimum API version 1.10 or higher</span></div>
<div class="line">    <span class="comment">// error handling</span></div>
<div class="line">    <span class="keywordflow">return</span>;</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="ttc" id="astruct_a_r_m___d_r_i_v_e_r___v_e_r_s_i_o_n_html"><div class="ttname"><a href="struct_a_r_m___d_r_i_v_e_r___v_e_r_s_i_o_n.html">ARM_DRIVER_VERSION</a></div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>This API returns synchronously&ndash;it does not result in an invocation of a completion callback.</dd>
<dd>
The function GetVersion() can be called any time to obtain the required information from the driver (even before initialization). It always returns the same information.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="struct_a_r_m___d_r_i_v_e_r___v_e_r_s_i_o_n.html">ARM_DRIVER_VERSION</a> </dd></dl>

</div>
</div>
<a id="gacc5dc090a35ac16caff8957030eaa174"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacc5dc090a35ac16caff8957030eaa174">&#9670;&nbsp;</a></span>ARM_Storage_Initialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ARM_Storage_Initialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__storage__interface__gr.html#ga4b290224fea782e6d2ad06f541b28a98">ARM_Storage_Callback_t</a>&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the Storage interface. </p>
<p>The function <b>ARM_Storage_Initialize</b> is called when the middleware component starts operation. In addition to bringing the controller to a ready state, Initialize() receives a callback handler to be invoked upon completion of asynchronous operations.</p>
<p><a class="el" href="group__storage__interface__gr.html#gacc5dc090a35ac16caff8957030eaa174" title="Initialize the Storage interface.">ARM_Storage_Initialize()</a> needs to be called explicitly before powering the peripheral using <a class="el" href="group__storage__interface__gr.html#ga979a2484bf05b2986de95a5d98307d54" title="Control the Storage interface power.">ARM_Storage_PowerControl()</a>, and before initiating other accesses to the storage controller.</p>
<p>The function performs the following operations:</p><ul>
<li>Initializes the resources needed for the Storage interface.</li>
<li>Registers the <a class="el" href="group__storage__interface__gr.html#ga4b290224fea782e6d2ad06f541b28a98">ARM_Storage_Callback_t</a> callback function.</li>
</ul>
<p>To start working with a peripheral the functions ARM_Storage_Initialize and <a class="el" href="group__storage__interface__gr.html#ga979a2484bf05b2986de95a5d98307d54" title="Control the Storage interface power.">ARM_Storage_PowerControl()</a> need to be called in this order: </p><div class="fragment"><div class="line">drv-&gt;Initialize (...);              <span class="comment">// Allocate I/O pins</span></div>
<div class="line">drv-&gt;PowerControl (ARM_POWER_FULL); <span class="comment">// Power up peripheral, setup IRQ/DMA</span></div>
</div><!-- fragment --><ul>
<li><a class="el" href="group__storage__interface__gr.html#gacc5dc090a35ac16caff8957030eaa174" title="Initialize the Storage interface.">ARM_Storage_Initialize()</a> typically allocates the I/O resources (pins) for the peripheral. The function can be called multiple times; if the I/O resources are already initialized it performs no operation and just returns with ARM_DRIVER_OK.</li>
<li>ARM_Storage_PowerControl (ARM_POWER_FULL) sets the peripheral registers including interrupt (NVIC) and optionally DMA. The function can be called multiple times; if the registers are already set it performs no operation and just returns with ARM_DRIVER_OK.</li>
</ul>
<p>To stop working with a peripheral the functions <a class="el" href="group__storage__interface__gr.html#ga979a2484bf05b2986de95a5d98307d54" title="Control the Storage interface power.">ARM_Storage_PowerControl()</a> and <a class="el" href="group__storage__interface__gr.html#ga1d14b15ddcda2836c6e3c1d0b5e60dca" title="De-initialize the Storage Interface.">ARM_Storage_Uninitialize()</a> need to be called in this order: </p><div class="fragment"><div class="line">drv-&gt;PowerControl (ARM_POWER_OFF); <span class="comment">// Terminate any pending transfers, reset IRQ/DMA, power off peripheral</span></div>
<div class="line">drv-&gt;Uninitialize (...);           <span class="comment">// Release I/O pins</span></div>
</div><!-- fragment --><p>The functions <a class="el" href="group__storage__interface__gr.html#ga979a2484bf05b2986de95a5d98307d54" title="Control the Storage interface power.">ARM_Storage_PowerControl()</a> and <a class="el" href="group__storage__interface__gr.html#ga1d14b15ddcda2836c6e3c1d0b5e60dca" title="De-initialize the Storage Interface.">ARM_Storage_Uninitialize()</a> always execute and can be used to put the peripheral into a Safe State, for example after any data transmission errors. To restart the peripheral in an error condition, you should first execute the Stop Sequence and then the Start Sequence.</p>
<dl class="section note"><dt>Note</dt><dd>This API may execute asynchronously if ARM_STORAGE_CAPABILITIES::asynchronous_ops is set. Asynchronous execution is optional even if 'asynchronous_ops' is set.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>Pointer to <a class="el" href="group__storage__interface__gr.html#ga4b290224fea782e6d2ad06f541b28a98">ARM_Storage_Callback_t</a>. Caller-defined callback to be invoked upon command completion for asynchronous APIs (including the completion of initialization). Use a NULL pointer when no callback signals are required. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If asynchronous activity is launched, invocation ARM_DRIVER_OK, and the caller can expect to receive a callback in the future with a status value of ARM_DRIVER_OK or an error-code. In the case of synchronous execution, control returns after completion with a value of 1. Return values less than ARM_DRIVER_OK (0) signify errors. </dd></dl>

</div>
</div>
<a id="ga979a2484bf05b2986de95a5d98307d54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga979a2484bf05b2986de95a5d98307d54">&#9670;&nbsp;</a></span>ARM_Storage_PowerControl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ARM_Storage_PowerControl </td>
          <td>(</td>
          <td class="paramtype">ARM_POWER_STATE&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Control the Storage interface power. </p>
<p>The function <b>ARM_Storage_PowerControl</b> operates the power modes of the Storage interface.</p>
<p>To start working with a peripheral the functions Initialize and PowerControl need to be called in this order: </p><div class="fragment"><div class="line">drv-&gt;Initialize (...);                 <span class="comment">// Allocate I/O pins</span></div>
<div class="line">drv-&gt;PowerControl (ARM_POWER_FULL);    <span class="comment">// Power up peripheral, setup IRQ/DMA</span></div>
</div><!-- fragment --><ul>
<li><a class="el" href="group__storage__interface__gr.html#gacc5dc090a35ac16caff8957030eaa174" title="Initialize the Storage interface.">ARM_Storage_Initialize()</a> typically allocates the I/O resources (pins) for the peripheral. The function can be called multiple times; if the I/O resources are already initialized it performs no operation and just returns with ARM_DRIVER_OK.</li>
<li>PowerControl (ARM_POWER_FULL) sets the peripheral registers including interrupt (NVIC) and optionally DMA. The function can be called multiple times; if the registers are already set it performs no operation and just returns with ARM_DRIVER_OK.</li>
</ul>
<p>To stop working with a peripheral the functions PowerControl and Uninitialize need to be called in this order: </p><div class="fragment"><div class="line">drv-&gt;PowerControl (ARM_POWER_OFF);     <span class="comment">// Terminate any pending transfers, reset IRQ/DMA, power off peripheral</span></div>
<div class="line">drv-&gt;Uninitialize (...);               <span class="comment">// Release I/O pins</span></div>
</div><!-- fragment --><p>The functions ARM_Storage_PowerControl and ARM_Storage_Uninitialize always execute and can be used to put the peripheral into a Safe State, for example after any data transmission errors. To restart the peripheral in an error condition, you should first execute the Stop Sequence and then the Start Sequence.</p>
<p>The parameter <em>state</em> can have the following values:</p><ul>
<li>ARM_POWER_FULL : set-up the Storage device for data transfers, enable interrupts (NVIC) and optionally DMA. Can be called multiple times. If the device is already in this mode, then the function performs no operation and returns with <a class="el" href="group__execution__status.html#ga85752c5de59e8adeb001e35ff5be6be7">ARM_DRIVER_OK</a>.</li>
<li>ARM_POWER_LOW : may use power saving. Returns <a class="el" href="group__execution__status.html#ga2efa59e480d82697795439220e6884e4">ARM_DRIVER_ERROR_UNSUPPORTED</a> when not implemented.</li>
<li>ARM_POWER_OFF : terminates any pending data transfers, disables peripheral, disables related interrupts and DMA.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>This API may execute asynchronously if ARM_STORAGE_CAPABILITIES::asynchronous_ops is set. Asynchronous execution is optional even if 'asynchronous_ops' is set.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>Power state </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If asynchronous activity is launched, an invocation returns ARM_DRIVER_OK, and the caller can expect to receive a callback in the future with a status value of ARM_DRIVER_OK or an error-code. In the case of synchronous execution, control returns after completion with a value of 1. Return values less than ARM_DRIVER_OK (0) signify errors. </dd></dl>

</div>
</div>
<a id="gabd20d561854c06918b0515b6c1bba230"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabd20d561854c06918b0515b6c1bba230">&#9670;&nbsp;</a></span>ARM_Storage_ProgramData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ARM_Storage_ProgramData </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Program data to Storage. </p>
<p>Write the contents of a given memory buffer into a range of storage memory. In the case of flash memory, the destination range in storage memory typically has its contents in an erased state from a preceding erase operation. The source memory buffer is owned by the caller and should remain accessible for the lifetime of this command.</p>
<dl class="section note"><dt>Note</dt><dd>It is best for the middleware to write in units of 'optimal_program_unit' (<a class="el" href="struct_a_r_m___s_t_o_r_a_g_e___i_n_f_o.html">ARM_STORAGE_INFO</a>) of the device.</dd>
<dd>
This API may execute asynchronously if ARM_STORAGE_CAPABILITIES::asynchronous_ops is set. Asynchronous execution is optional even if 'asynchronous_ops' is set.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>This is the start address of the range to be written into. It needs to be aligned to the device's <em>program_unit</em> specified in <a class="el" href="struct_a_r_m___s_t_o_r_a_g_e___i_n_f_o.html">ARM_STORAGE_INFO</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The source of the write operation. The buffer is owned by the caller and should remain accessible for the lifetime of this command. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The number of bytes requested to be written. The buffer should be at least as large as this size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>'size' should be a multiple of the device's 'program_unit' (see <a class="el" href="struct_a_r_m___s_t_o_r_a_g_e___i_n_f_o.html">ARM_STORAGE_INFO</a>). </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>If asynchronous activity is launched, an invocation returns ARM_DRIVER_OK, and the caller can expect to receive a callback in the future with the number of successfully transferred bytes passed in as the 'status' parameter. In the case of synchronous execution, control returns after completion with a positive transfer-count. Return values less than ARM_DRIVER_OK (0) signify errors. </dd></dl>

</div>
</div>
<a id="gabaa24553c165add98020434c980b3ab4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabaa24553c165add98020434c980b3ab4">&#9670;&nbsp;</a></span>ARM_Storage_ReadData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ARM_Storage_ReadData </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read data from Storage. </p>
<p>Read the contents of a range of storage memory into a buffer supplied by the caller. The buffer is owned by the caller and should remain accessible for the lifetime of this command.</p>
<dl class="section note"><dt>Note</dt><dd>This API may execute asynchronously if ARM_STORAGE_CAPABILITIES::asynchronous_ops is set. Asynchronous execution is optional even if 'asynchronous_ops' is set.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>Data address. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>Pointer to a buffer storing the data read from Storage. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Number of bytes to read. The data buffer should be at least as large as this size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If asynchronous activity is launched, an invocation returns ARM_DRIVER_OK, and the caller can expect to receive a callback in the future with the number of successfully transferred bytes passed in as the 'status' parameter. In the case of synchronous execution, control returns after completion with a positive transfer-count. Return values less than ARM_DRIVER_OK (0) signify errors. </dd></dl>

</div>
</div>
<a id="ga5a1934750a51c74b8b0fea52588a3b9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5a1934750a51c74b8b0fea52588a3b9a">&#9670;&nbsp;</a></span>ARM_Storage_ResolveAddress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t ARM_Storage_ResolveAddress </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resolve an address relative to the storage controller into a memory address. </p>
<p>Only applicable to devices with memory-mapped storage.</p>
<dl class="section note"><dt>Note</dt><dd>This API returns synchronously. The invocation should return quickly, and result in a resolved address.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>The address for which we want a resolution to the processor's physical address space. It is an offset from the start of the storage map maintained by the owning storage controller. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resolved address in the processor's address space, else ARM_STORAGE_INVALID_ADDRESS. </dd></dl>

</div>
</div>
<a id="ga1d14b15ddcda2836c6e3c1d0b5e60dca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1d14b15ddcda2836c6e3c1d0b5e60dca">&#9670;&nbsp;</a></span>ARM_Storage_Uninitialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ARM_Storage_Uninitialize </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>De-initialize the Storage Interface. </p>
<p>It is called when the middleware component stops operation, and wishes to release the software resources used by the interface.</p>
<dl class="section note"><dt>Note</dt><dd>This API may execute asynchronously if ARM_STORAGE_CAPABILITIES::asynchronous_ops is set. Asynchronous execution is optional even if 'asynchronous_ops' is set.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>If asynchronous activity is launched, an invocation returns ARM_DRIVER_OK, and the caller can expect to receive a callback in the future with a status value of ARM_DRIVER_OK or an error-code. In the case of synchronous execution, control returns after completion with a value of 1. Return values less than ARM_DRIVER_OK (0) signify errors. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
