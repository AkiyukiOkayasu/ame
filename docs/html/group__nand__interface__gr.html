<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AME: NAND Interface</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">AME
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__nand__interface__gr.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">NAND Interface</div>  </div>
</div><!--header-->
<div class="contents">

<p>Driver API for NAND Flash Device Interface (Driver_NAND.h).  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__nand__execution__status"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nand__execution__status.html">Status Error Codes</a></td></tr>
<tr class="memdesc:group__nand__execution__status"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negative values indicate errors (NAND has specific codes in addition to common <a class="el" href="group__execution__status.html">Status Error Codes</a>). <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group___n_a_n_d__events"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___n_a_n_d__events.html">NAND Events</a></td></tr>
<tr class="memdesc:group___n_a_n_d__events"><td class="mdescLeft">&#160;</td><td class="mdescRight">The NAND driver generates call back events that are notified via the function <a class="el" href="group__nand__interface__gr.html#gaf4ce80b0fd6717de7ddfb1cfaf7dd754">ARM_NAND_SignalEvent</a>. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__nand__driver__flag__codes"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nand__driver__flag__codes.html">NAND Flags</a></td></tr>
<tr class="memdesc:group__nand__driver__flag__codes"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify Flag codes. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__nand__control__gr"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nand__control__gr.html">NAND Control Codes</a></td></tr>
<tr class="memdesc:group__nand__control__gr"><td class="mdescLeft">&#160;</td><td class="mdescRight">Many parameters of the NAND driver are configured using the <a class="el" href="group__nand__interface__gr.html#ga83061d6d53ffb148853efbc87a864607">ARM_NAND_Control</a> function. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__nand__driver__ecc__codes"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nand__driver__ecc__codes.html">NAND ECC Codes</a></td></tr>
<tr class="memdesc:group__nand__driver__ecc__codes"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify ECC codes. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__nand__driver__seq__exec__codes"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nand__driver__seq__exec__codes.html">NAND Sequence Execution Codes</a></td></tr>
<tr class="memdesc:group__nand__driver__seq__exec__codes"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify execution codes. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_r_m___n_a_n_d___s_t_a_t_u_s.html">ARM_NAND_STATUS</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_r_m___d_r_i_v_e_r___n_a_n_d.html">ARM_DRIVER_NAND</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_r_m___n_a_n_d___c_a_p_a_b_i_l_i_t_i_e_s.html">ARM_NAND_CAPABILITIES</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_r_m___n_a_n_d___e_c_c___i_n_f_o.html">ARM_NAND_ECC_INFO</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga09f4cf2f2df0bb690bce38b13d77e50f"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nand__interface__gr.html#ga09f4cf2f2df0bb690bce38b13d77e50f">ARM_NAND_SignalEvent_t</a>) (uint32_t dev_num, uint32_t event)</td></tr>
<tr class="memdesc:ga09f4cf2f2df0bb690bce38b13d77e50f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to <a class="el" href="group__nand__interface__gr.html#gaf4ce80b0fd6717de7ddfb1cfaf7dd754">ARM_NAND_SignalEvent</a> : Signal NAND Event.  <a href="group__nand__interface__gr.html#ga09f4cf2f2df0bb690bce38b13d77e50f">More...</a><br /></td></tr>
<tr class="separator:ga09f4cf2f2df0bb690bce38b13d77e50f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga01255fd4f15e7fa4751c7ea59648ef5a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_a_r_m___d_r_i_v_e_r___v_e_r_s_i_o_n.html">ARM_DRIVER_VERSION</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nand__interface__gr.html#ga01255fd4f15e7fa4751c7ea59648ef5a">ARM_NAND_GetVersion</a> (void)</td></tr>
<tr class="memdesc:ga01255fd4f15e7fa4751c7ea59648ef5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get driver version.  <a href="group__nand__interface__gr.html#ga01255fd4f15e7fa4751c7ea59648ef5a">More...</a><br /></td></tr>
<tr class="separator:ga01255fd4f15e7fa4751c7ea59648ef5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f2609975c2008d21b9ae28f15daf147"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_a_r_m___n_a_n_d___c_a_p_a_b_i_l_i_t_i_e_s.html">ARM_NAND_CAPABILITIES</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nand__interface__gr.html#ga9f2609975c2008d21b9ae28f15daf147">ARM_NAND_GetCapabilities</a> (void)</td></tr>
<tr class="memdesc:ga9f2609975c2008d21b9ae28f15daf147"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get driver capabilities.  <a href="group__nand__interface__gr.html#ga9f2609975c2008d21b9ae28f15daf147">More...</a><br /></td></tr>
<tr class="separator:ga9f2609975c2008d21b9ae28f15daf147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74ad34718a595e7a4375b90f33e72750"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nand__interface__gr.html#ga74ad34718a595e7a4375b90f33e72750">ARM_NAND_Initialize</a> (<a class="el" href="group__nand__interface__gr.html#ga09f4cf2f2df0bb690bce38b13d77e50f">ARM_NAND_SignalEvent_t</a> cb_event)</td></tr>
<tr class="memdesc:ga74ad34718a595e7a4375b90f33e72750"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the NAND Interface.  <a href="group__nand__interface__gr.html#ga74ad34718a595e7a4375b90f33e72750">More...</a><br /></td></tr>
<tr class="separator:ga74ad34718a595e7a4375b90f33e72750"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa788b638ab696b166fee2f4a4bc8d97a"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nand__interface__gr.html#gaa788b638ab696b166fee2f4a4bc8d97a">ARM_NAND_Uninitialize</a> (void)</td></tr>
<tr class="memdesc:gaa788b638ab696b166fee2f4a4bc8d97a"><td class="mdescLeft">&#160;</td><td class="mdescRight">De-initialize the NAND Interface.  <a href="group__nand__interface__gr.html#gaa788b638ab696b166fee2f4a4bc8d97a">More...</a><br /></td></tr>
<tr class="separator:gaa788b638ab696b166fee2f4a4bc8d97a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c9975637980b5d42db7baba0191fda1"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nand__interface__gr.html#ga9c9975637980b5d42db7baba0191fda1">ARM_NAND_PowerControl</a> (ARM_POWER_STATE state)</td></tr>
<tr class="memdesc:ga9c9975637980b5d42db7baba0191fda1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control the NAND interface power.  <a href="group__nand__interface__gr.html#ga9c9975637980b5d42db7baba0191fda1">More...</a><br /></td></tr>
<tr class="separator:ga9c9975637980b5d42db7baba0191fda1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11adcbaaace09746581a36befbd563c9"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nand__interface__gr.html#ga11adcbaaace09746581a36befbd563c9">ARM_NAND_DevicePower</a> (uint32_t voltage)</td></tr>
<tr class="memdesc:ga11adcbaaace09746581a36befbd563c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set device power supply voltage.  <a href="group__nand__interface__gr.html#ga11adcbaaace09746581a36befbd563c9">More...</a><br /></td></tr>
<tr class="separator:ga11adcbaaace09746581a36befbd563c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1987e65a4e756d748db86332c9fb1cec"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nand__interface__gr.html#ga1987e65a4e756d748db86332c9fb1cec">ARM_NAND_WriteProtect</a> (uint32_t dev_num, bool enable)</td></tr>
<tr class="memdesc:ga1987e65a4e756d748db86332c9fb1cec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control WPn (Write Protect).  <a href="group__nand__interface__gr.html#ga1987e65a4e756d748db86332c9fb1cec">More...</a><br /></td></tr>
<tr class="separator:ga1987e65a4e756d748db86332c9fb1cec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c0cba87cb7b706ad5986dc67c831ad1"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nand__interface__gr.html#ga1c0cba87cb7b706ad5986dc67c831ad1">ARM_NAND_ChipEnable</a> (uint32_t dev_num, bool enable)</td></tr>
<tr class="memdesc:ga1c0cba87cb7b706ad5986dc67c831ad1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control CEn (Chip Enable).  <a href="group__nand__interface__gr.html#ga1c0cba87cb7b706ad5986dc67c831ad1">More...</a><br /></td></tr>
<tr class="separator:ga1c0cba87cb7b706ad5986dc67c831ad1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43011066306bd716b580e6aa9a80cf65"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nand__interface__gr.html#ga43011066306bd716b580e6aa9a80cf65">ARM_NAND_GetDeviceBusy</a> (uint32_t dev_num)</td></tr>
<tr class="memdesc:ga43011066306bd716b580e6aa9a80cf65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Device Busy pin state.  <a href="group__nand__interface__gr.html#ga43011066306bd716b580e6aa9a80cf65">More...</a><br /></td></tr>
<tr class="separator:ga43011066306bd716b580e6aa9a80cf65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f70b89ba478eadfe7f5dee7453a4fb7"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nand__interface__gr.html#ga9f70b89ba478eadfe7f5dee7453a4fb7">ARM_NAND_SendCommand</a> (uint32_t dev_num, uint8_t cmd)</td></tr>
<tr class="memdesc:ga9f70b89ba478eadfe7f5dee7453a4fb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send command to NAND device.  <a href="group__nand__interface__gr.html#ga9f70b89ba478eadfe7f5dee7453a4fb7">More...</a><br /></td></tr>
<tr class="separator:ga9f70b89ba478eadfe7f5dee7453a4fb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00e195031e03d364db7595858a7e76f3"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nand__interface__gr.html#ga00e195031e03d364db7595858a7e76f3">ARM_NAND_SendAddress</a> (uint32_t dev_num, uint8_t addr)</td></tr>
<tr class="memdesc:ga00e195031e03d364db7595858a7e76f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send address to NAND device.  <a href="group__nand__interface__gr.html#ga00e195031e03d364db7595858a7e76f3">More...</a><br /></td></tr>
<tr class="separator:ga00e195031e03d364db7595858a7e76f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1899a20ef107400c8bf84fad477a8ce"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nand__interface__gr.html#gae1899a20ef107400c8bf84fad477a8ce">ARM_NAND_ReadData</a> (uint32_t dev_num, void *data, uint32_t cnt, uint32_t mode)</td></tr>
<tr class="memdesc:gae1899a20ef107400c8bf84fad477a8ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data from NAND device.  <a href="group__nand__interface__gr.html#gae1899a20ef107400c8bf84fad477a8ce">More...</a><br /></td></tr>
<tr class="separator:gae1899a20ef107400c8bf84fad477a8ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1fa497dd51a86fc308e946b4419fd006"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nand__interface__gr.html#ga1fa497dd51a86fc308e946b4419fd006">ARM_NAND_WriteData</a> (uint32_t dev_num, const void *data, uint32_t cnt, uint32_t mode)</td></tr>
<tr class="memdesc:ga1fa497dd51a86fc308e946b4419fd006"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data to NAND device.  <a href="group__nand__interface__gr.html#ga1fa497dd51a86fc308e946b4419fd006">More...</a><br /></td></tr>
<tr class="separator:ga1fa497dd51a86fc308e946b4419fd006"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a0108dba757a4610475151144b52825"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nand__interface__gr.html#ga8a0108dba757a4610475151144b52825">ARM_NAND_ExecuteSequence</a> (uint32_t dev_num, uint32_t code, uint32_t cmd, uint32_t addr_col, uint32_t addr_row, void *data, uint32_t data_cnt, uint8_t *status, uint32_t *count)</td></tr>
<tr class="memdesc:ga8a0108dba757a4610475151144b52825"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute sequence of operations.  <a href="group__nand__interface__gr.html#ga8a0108dba757a4610475151144b52825">More...</a><br /></td></tr>
<tr class="separator:ga8a0108dba757a4610475151144b52825"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00832861f018db0d8368900b099ecd30"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nand__interface__gr.html#ga00832861f018db0d8368900b099ecd30">ARM_NAND_AbortSequence</a> (uint32_t dev_num)</td></tr>
<tr class="memdesc:ga00832861f018db0d8368900b099ecd30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abort sequence execution.  <a href="group__nand__interface__gr.html#ga00832861f018db0d8368900b099ecd30">More...</a><br /></td></tr>
<tr class="separator:ga00832861f018db0d8368900b099ecd30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83061d6d53ffb148853efbc87a864607"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nand__interface__gr.html#ga83061d6d53ffb148853efbc87a864607">ARM_NAND_Control</a> (uint32_t dev_num, uint32_t control, uint32_t arg)</td></tr>
<tr class="memdesc:ga83061d6d53ffb148853efbc87a864607"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control NAND Interface.  <a href="group__nand__interface__gr.html#ga83061d6d53ffb148853efbc87a864607">More...</a><br /></td></tr>
<tr class="separator:ga83061d6d53ffb148853efbc87a864607"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4578642f37a556b58b0bba0ad5d42641"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_a_r_m___n_a_n_d___s_t_a_t_u_s.html">ARM_NAND_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nand__interface__gr.html#ga4578642f37a556b58b0bba0ad5d42641">ARM_NAND_GetStatus</a> (uint32_t dev_num)</td></tr>
<tr class="memdesc:ga4578642f37a556b58b0bba0ad5d42641"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get NAND status.  <a href="group__nand__interface__gr.html#ga4578642f37a556b58b0bba0ad5d42641">More...</a><br /></td></tr>
<tr class="separator:ga4578642f37a556b58b0bba0ad5d42641"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac21425454d586ef48fdfc35e7bd78947"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nand__interface__gr.html#gac21425454d586ef48fdfc35e7bd78947">ARM_NAND_InquireECC</a> (int32_t index, <a class="el" href="struct_a_r_m___n_a_n_d___e_c_c___i_n_f_o.html">ARM_NAND_ECC_INFO</a> *info)</td></tr>
<tr class="memdesc:gac21425454d586ef48fdfc35e7bd78947"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inquire about available ECC.  <a href="group__nand__interface__gr.html#gac21425454d586ef48fdfc35e7bd78947">More...</a><br /></td></tr>
<tr class="separator:gac21425454d586ef48fdfc35e7bd78947"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4ce80b0fd6717de7ddfb1cfaf7dd754"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nand__interface__gr.html#gaf4ce80b0fd6717de7ddfb1cfaf7dd754">ARM_NAND_SignalEvent</a> (uint32_t dev_num, uint32_t event)</td></tr>
<tr class="memdesc:gaf4ce80b0fd6717de7ddfb1cfaf7dd754"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal NAND event.  <a href="group__nand__interface__gr.html#gaf4ce80b0fd6717de7ddfb1cfaf7dd754">More...</a><br /></td></tr>
<tr class="separator:gaf4ce80b0fd6717de7ddfb1cfaf7dd754"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Driver API for NAND Flash Device Interface (Driver_NAND.h). </p>
<p><b>NAND</b> devices are a type of non-volatile storage and do not require power to hold data. Wikipedia offers more information about the <a href="http://en.wikipedia.org/wiki/Flash_memory#ARM_NAND_memories" target="_blank"><b>Flash Memories</b></a>, including NAND.</p>
<p><b>Block Diagram</b></p>
<p>&#160;</p>
<div class="image">
<img src="NAND_Schematics.png" alt=""/>
<div class="caption">
Simplified NAND Flash Schematic</div></div>
 <p>&#160;</p>
<p><b>NAND API</b></p>
<p>The following header files define the Application Programming Interface (API) for the NAND interface:</p><ul>
<li><b>Driver_NAND.h</b> : Driver API for NAND Flash Device Interface</li>
</ul>
<p>The driver implementation is a typical part of the Device Family Pack (DFP) that supports the peripherals of the microcontroller family.</p>
<p>NAND Flash is organized in pages, grouped into blocks as the smallest erasable unit. The addressing of data is achieved by <code>byte_address = block * block_size + page_in_block * page_size + offset_in_page</code>. In terms of this NAND API blocks and pages are referred to as <code>row</code> and the byte offset within the page as <code>col</code>. Thus one can calculate the <code>byte_address = row * page_size + col</code>. The parameters <code>page_size</code> and <code>block_size</code> are device specific and must be handled by the driver user appropriately.</p>
<p><b>Driver Functions</b></p>
<p>The driver functions are published in the access struct as explained in DriverFunctions</p><ul>
<li><a class="el" href="struct_a_r_m___d_r_i_v_e_r___n_a_n_d.html">ARM_DRIVER_NAND</a> : access struct for NAND driver functions</li>
</ul>
<p><a class="anchor" id="example"></a><b>Example Code:</b></p>
<div class="fragment"></div><!-- fragment --> <h2 class="groupheader">Typedef Documentation</h2>
<a id="ga09f4cf2f2df0bb690bce38b13d77e50f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga09f4cf2f2df0bb690bce38b13d77e50f">&#9670;&nbsp;</a></span>ARM_NAND_SignalEvent_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ARM_NAND_SignalEvent_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pointer to <a class="el" href="group__nand__interface__gr.html#gaf4ce80b0fd6717de7ddfb1cfaf7dd754">ARM_NAND_SignalEvent</a> : Signal NAND Event. </p>
<p>Provides the typedef for the callback function <a class="el" href="group__nand__interface__gr.html#gaf4ce80b0fd6717de7ddfb1cfaf7dd754">ARM_NAND_SignalEvent</a>.</p>
<p><b>Parameter for:</b></p><ul>
<li><a class="el" href="group__nand__interface__gr.html#ga74ad34718a595e7a4375b90f33e72750">ARM_NAND_Initialize</a> </li>
</ul>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga00832861f018db0d8368900b099ecd30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga00832861f018db0d8368900b099ecd30">&#9670;&nbsp;</a></span>ARM_NAND_AbortSequence()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ARM_NAND_AbortSequence </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>dev_num</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Abort sequence execution. </p>
<p>The function <b>ARM_NAND_AbortSequence</b> aborts execution of the current sequence for a NAND device.</p>
<p>The parameter <em>dev_num</em> is the device number.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev_num</td><td>Device number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__execution__status.html">Status Error Codes</a> </dd></dl>

</div>
</div>
<a id="ga1c0cba87cb7b706ad5986dc67c831ad1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1c0cba87cb7b706ad5986dc67c831ad1">&#9670;&nbsp;</a></span>ARM_NAND_ChipEnable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ARM_NAND_ChipEnable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>dev_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Control CEn (Chip Enable). </p>
<p>The function <b>ARM_NAND_ChipEnable</b> control the Chip Enable (CEn) pin of a NAND device.</p>
<p>The parameter <em>dev_num</em> is the device number. <br  />
 The parameter <em>enable</em> specifies whether to enable or disable the device.</p>
<p>This function is optional and supported only when the data field <em>ce_manual</em> = \token{1} in the structure <a class="el" href="struct_a_r_m___n_a_n_d___c_a_p_a_b_i_l_i_t_i_e_s.html">ARM_NAND_CAPABILITIES</a>. Otherwise, the Chip Enable (CEn) signal is controlled automatically by SendCommand/Address, Read/WriteData and ExecuteSequence (for example when the NAND device is connected to a memory bus).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev_num</td><td>Device number </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">enable</td><td><ul>
<li><b>false</b> Chip Enable off</li>
<li><b>true</b> Chip Enable on </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__execution__status.html">Status Error Codes</a> </dd></dl>

</div>
</div>
<a id="ga83061d6d53ffb148853efbc87a864607"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga83061d6d53ffb148853efbc87a864607">&#9670;&nbsp;</a></span>ARM_NAND_Control()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ARM_NAND_Control </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>dev_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>control</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Control NAND Interface. </p>
<p>The function <b>ARM_NAND_Control</b> controls the NAND interface and executes operations.</p>
<p>The parameter <em>dev_num</em> is the device number. <br  />
The parameter <em>control</em> specifies the operation. <br  />
The parameter <em>arg</em> provides (depending on the <em>control</em>) additional information or sets values.</p>
<p>The table lists the operations for the parameter <em>control</em>.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Parameter <em>control</em>   </th><th class="markdownTableHeadLeft">Operation    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">ARM_NAND_BUS_MODE   </td><td class="markdownTableBodyLeft">Set the bus mode. The parameter <em>arg</em> sets the <a class="el" href="group__nand__interface__gr.html#bus_mode_tab"><b>Bus</b> Mode</a>.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">ARM_NAND_BUS_DATA_WIDTH   </td><td class="markdownTableBodyLeft">Set the data bus width. The parameter <em>arg</em> sets the <a class="el" href="group__nand__interface__gr.html#bus_data_width_tab"><b>Bus</b> Data Width</a>.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">ARM_NAND_DRIVER_STRENGTH   </td><td class="markdownTableBodyLeft">Set the driver strength. The parameter <em>arg</em> sets the <a class="el" href="group__nand__interface__gr.html#driver_strength_tab"><b>Driver</b> Strength</a>.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">ARM_NAND_DRIVER_READY_EVENT   </td><td class="markdownTableBodyLeft">Control generation of callback event <a class="el" href="group___n_a_n_d__events.html#ga7b390a906db42c5ea4db38e0e85bb9e9">ARM_NAND_EVENT_DRIVER_READY</a>. Enable: <em>arg</em> = \token{1}. Disable: <em>arg</em> = \token{0}.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">ARM_NAND_DEVICE_READY_EVENT   </td><td class="markdownTableBodyLeft">Control generation of callback event <a class="el" href="group___n_a_n_d__events.html#gae0be7e1b41188def905de0a1568d442d">ARM_NAND_EVENT_DEVICE_READY</a>; Enable: <em>arg</em> = \token{1}. Disable: <em>arg</em> = \token{0}.   </td></tr>
</table>
<p><b>See Also</b></p><ul>
<li><a class="el" href="group__nand__interface__gr.html#ga9f2609975c2008d21b9ae28f15daf147">ARM_NAND_GetCapabilities</a> returns information about supported operations, which are stored in the structure <a class="el" href="struct_a_r_m___n_a_n_d___c_a_p_a_b_i_l_i_t_i_e_s.html">ARM_NAND_CAPABILITIES</a>.</li>
<li><a class="el" href="group__nand__interface__gr.html#gaf4ce80b0fd6717de7ddfb1cfaf7dd754">ARM_NAND_SignalEvent</a> provides information about the callback events <a class="el" href="group___n_a_n_d__events.html#ga7b390a906db42c5ea4db38e0e85bb9e9">ARM_NAND_EVENT_DRIVER_READY</a> and <a class="el" href="group___n_a_n_d__events.html#gae0be7e1b41188def905de0a1568d442d">ARM_NAND_EVENT_DEVICE_READY</a></li>
</ul>
<p>The table lists values for the parameter <em>arg</em> used with the <em>control</em> operation ARM_NAND_BUS_MODE, ARM_NAND_BUS_DATA_WIDTH, and ARM_NAND_DRIVER_STRENGTH. Values from different categories can be ORed.</p>
<p><a class="anchor" id="bus_mode_tab"></a></p><table class="cmtable">
<tr>
<th>Parameter <em>arg</em> <br  />
 for <em>control</em> = ARM_NAND_BUS_MODE  </th><th>Bit  </th><th>Category  </th><th>Description  </th><th width="30%">Supported when <a class="el" href="struct_a_r_m___n_a_n_d___c_a_p_a_b_i_l_i_t_i_e_s.html">ARM_NAND_CAPABILITIES</a>  </th></tr>
<tr>
<td>ARM_NAND_BUS_TIMING_MODE_0 (default)  </td><td rowspan="8" style="text-align:right">0..3  </td><td rowspan="8"><a class="anchor" id="bus_timing_tab"></a> Bus Timing Mode  </td><td>\token{0}  </td><td rowspan="8">The maximum timing mode that can be applied to a specific <a class="el" href="group__nand__interface__gr.html#bus_data_interface_tab"><b>Bus</b> Data Interface</a> is stored in the data fields: <br  />
<br  />
 <em>sdr_timing_mode</em> - for SDR <br  />
 <em>ddr_timing_mode</em> - for NV-DDR <br  />
 <em>ddr2_timing_mode</em> - for NV_DDR2  </td></tr>
<tr>
<td>ARM_NAND_BUS_TIMING_MODE_1 </td><td>\token{1}  </td></tr>
<tr>
<td>ARM_NAND_BUS_TIMING_MODE_2 </td><td>\token{2}  </td></tr>
<tr>
<td>ARM_NAND_BUS_TIMING_MODE_3 </td><td>\token{3}  </td></tr>
<tr>
<td>ARM_NAND_BUS_TIMING_MODE_4 </td><td>\token{4} (SDR EDO capable)  </td></tr>
<tr>
<td>ARM_NAND_BUS_TIMING_MODE_5 </td><td>\token{5} (SDR EDO capable)  </td></tr>
<tr>
<td>ARM_NAND_BUS_TIMING_MODE_6 </td><td>\token{6} (NV-DDR2 only)  </td></tr>
<tr>
<td>ARM_NAND_BUS_TIMING_MODE_7 </td><td>\token{7} (NV-DDR2 only)  </td></tr>
<tr>
<td>ARM_NAND_BUS_SDR (default)<a class="anchor" id="bus_data_interface_tab"></a>  </td><td rowspan="3" style="text-align:right">4..7  </td><td rowspan="3">Bus Data Interface  </td><td>SDR (Single Data Rate) - Traditional interface  </td><td><em>always supported</em>  </td></tr>
<tr>
<td>ARM_NAND_BUS_DDR </td><td>NV-DDR (Double Data Rate) </td><td>data field <em>ddr</em> = \token{1}  </td></tr>
<tr>
<td>ARM_NAND_BUS_DDR2 </td><td>NV-DDR2 (Double Data Rate) </td><td>data field <em>ddr2</em> = \token{1}  </td></tr>
<tr>
<td style="white-space: nowrap">ARM_NAND_BUS_DDR2_DO_WCYC_0 (default)  </td><td rowspan="4" style="text-align:right">8..11  </td><td rowspan="4" style="white-space: nowrap">Data Output Warm-up<a class="anchor" id="bus_output_tab"></a>  </td><td>Set the DDR2 Data Output Warm-up to \token{0} cycles  </td><td rowspan="4"><b>Data Output Warm-up</b> cycles are dummy cycles for interface calibration with no incremental data transfer and apply to NV-DDR2 of the <a class="el" href="group__nand__interface__gr.html#bus_data_interface_tab"><b>Bus</b> Data Interface</a>. <br  />
  </td></tr>
<tr>
<td>ARM_NAND_BUS_DDR2_DO_WCYC_1 </td><td>Set the DDR2 Data Output Warm-up to \token{1} cycles  </td></tr>
<tr>
<td>ARM_NAND_BUS_DDR2_DO_WCYC_2 </td><td>Set the DDR2 Data Output Warm-up to \token{2} cycles  </td></tr>
<tr>
<td>ARM_NAND_BUS_DDR2_DO_WCYC_4 </td><td>Set the DDR2 Data Output Warm-up to \token{4} cycles  </td></tr>
<tr>
<td style="white-space: nowrap">ARM_NAND_BUS_DDR2_DI_WCYC_0 (default)<a class="anchor" id="bus_input_tab"></a> </td><td rowspan="4" style="text-align:right">12..15  </td><td rowspan="4" style="white-space: nowrap">Data Input Warm-up  </td><td>Set the DDR2 Data Input Warm-up to \token{0} cycles  </td><td rowspan="4"><b>Data Input Warm-up</b> cycles are dummy cycles for interface calibration with no incremental data transfer and apply to NV-DDR2 of the <a class="el" href="group__nand__interface__gr.html#bus_data_interface_tab"><b>Bus</b> Data Interface</a>. <br  />
  </td></tr>
<tr>
<td>ARM_NAND_BUS_DDR2_DI_WCYC_1 </td><td>Set the DDR2 Data Input Warm-up to \token{1} cycles  </td></tr>
<tr>
<td>ARM_NAND_BUS_DDR2_DI_WCYC_2 </td><td>Set the DDR2 Data Input Warm-up to \token{2} cycles  </td></tr>
<tr>
<td>ARM_NAND_BUS_DDR2_DI_WCYC_4 </td><td>Set the DDR2 Data Input Warm-up to \token{4} cycles  </td></tr>
<tr>
<td style="white-space: nowrap">ARM_NAND_BUS_DDR2_VEN bus_misc_tab  </td><td style="text-align:right">16  </td><td rowspan="3" style="white-space: nowrap">Miscellaneous  </td><td>Set the DDR2 Enable external VREFQ as reference  </td><td rowspan="3">&#160;  </td></tr>
<tr>
<td>ARM_NAND_BUS_DDR2_CMPD </td><td style="text-align:right">17 </td><td>Set the DDR2 Enable complementary DQS (DQS_c) signal  </td></tr>
<tr>
<td>ARM_NAND_BUS_DDR2_CMPR </td><td style="text-align:right">18 </td><td>Set the DDR2 Enable complementary RE_n (RE_c) signal  </td></tr>
<tr>
<th>Parameter <em>arg</em> <br  />
 for <em>control</em> = ARM_NAND_BUS_DATA_WIDTH  </th><th>Bit  </th><th>Category<a class="anchor" id="bus_data_width_tab"></a>  </th><th>Description  </th><th width="30%">Supported when <a class="el" href="struct_a_r_m___n_a_n_d___c_a_p_a_b_i_l_i_t_i_e_s.html">ARM_NAND_CAPABILITIES</a>  </th></tr>
<tr>
<td style="white-space: nowrap">ARM_NAND_BUS_DATA_WIDTH_8 (default)  </td><td rowspan="2" style="text-align:right">0..1  </td><td rowspan="2" style="white-space: nowrap">Bus Data Width  </td><td>Set to \token{8 bit}  </td><td><em>always supported</em>  </td></tr>
<tr>
<td>ARM_NAND_BUS_DATA_WIDTH_16 </td><td>Set to \token{16 bit} </td><td>data field <em>data_width_16</em> = \token{1}  </td></tr>
<tr>
<th style="white-space: nowrap">Parameter <em>arg</em> <br  />
 for <em>control</em> = ARM_NAND_DRIVER_STRENGTH  </th><th>Bit  </th><th>Category<a class="anchor" id="driver_strength_tab"></a>  </th><th>Description  </th><th width="30%">Supported when <a class="el" href="struct_a_r_m___n_a_n_d___c_a_p_a_b_i_l_i_t_i_e_s.html">ARM_NAND_CAPABILITIES</a>  </th></tr>
<tr>
<td style="white-space: nowrap"><a class="el" href="group__nand__driver__strength__codes.html#ga942e20df12022f3bbd0e9a558ec1c7a0">ARM_NAND_DRIVER_STRENGTH_18</a>  </td><td rowspan="4" style="text-align:right">0..3  </td><td rowspan="4" style="white-space: nowrap">Driver Strength  </td><td>Set the Driver Strength 2.0x = 18 Ohms  </td><td>data field <em>driver_strength_18</em> = \token{1}  </td></tr>
<tr>
<td><a class="el" href="group__nand__driver__strength__codes.html#ga17188e039f5f87c581033327399a057d">ARM_NAND_DRIVER_STRENGTH_25</a> </td><td>Set the Driver Strength 1.4x = 25 Ohms </td><td>data field <em>driver_strength_25</em> = \token{1}  </td></tr>
<tr>
<td><a class="el" href="group__nand__driver__strength__codes.html#ga33562a66a5bf328eea82b2f1893a7874">ARM_NAND_DRIVER_STRENGTH_35</a> (default) </td><td>Set the Driver Strength 1.0x = 35 Ohms </td><td><em>always supported</em>  </td></tr>
<tr>
<td><a class="el" href="group__nand__driver__strength__codes.html#gaa502e2c995447037d266f939faa43223">ARM_NAND_DRIVER_STRENGTH_50</a> </td><td>Set the Driver Strength 0.7x = 50 Ohms </td><td>data field <em>driver_strength_50</em> = \token{1}  </td></tr>
</table>
<p><b>Example</b> </p><div class="fragment"><div class="line"><span class="keyword">extern</span> <a class="code" href="struct_a_r_m___d_r_i_v_e_r___n_a_n_d.html">ARM_DRIVER_NAND</a> Driver_NAND0;</div>
<div class="line"> </div>
<div class="line">status = Driver_NAND0.Control (0, ARM_NAND_BUS_MODE, ARM_NAND_BUS_TIMING_MODE_5 | </div>
<div class="line">                                                     ARM_NAND_BUS_DDR2          | </div>
<div class="line">                                                     ARM_NAND_BUS_DDR2_VEN);</div>
<div class="line">                                                </div>
<div class="line">status = Driver_NAND0.Control (0, ARM_NAND_BUS_DATA_WIDTH,  ARM_NAND_BUS_DATA_WIDTH_16); </div>
<div class="line"> </div>
<div class="line">status = Driver_NAND0.Control (0, ARM_NAND_DRIVER_STRENGTH, <a class="code" href="group__nand__driver__strength__codes.html#gaa502e2c995447037d266f939faa43223">ARM_NAND_DRIVER_STRENGTH_50</a>);</div>
<div class="ttc" id="agroup__nand__driver__strength__codes_html_gaa502e2c995447037d266f939faa43223"><div class="ttname"><a href="group__nand__driver__strength__codes.html#gaa502e2c995447037d266f939faa43223">ARM_NAND_DRIVER_STRENGTH_50</a></div><div class="ttdeci">#define ARM_NAND_DRIVER_STRENGTH_50</div><div class="ttdoc">Driver Strength 0.7x = 50 Ohms.</div><div class="ttdef"><b>Definition:</b> Driver_NAND.h:127</div></div>
<div class="ttc" id="astruct_a_r_m___d_r_i_v_e_r___n_a_n_d_html"><div class="ttname"><a href="struct_a_r_m___d_r_i_v_e_r___n_a_n_d.html">ARM_DRIVER_NAND</a></div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev_num</td><td>Device number </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">control</td><td>Operation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>Argument of operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__execution__status.html">Status Error Codes</a> </dd></dl>

</div>
</div>
<a id="ga11adcbaaace09746581a36befbd563c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga11adcbaaace09746581a36befbd563c9">&#9670;&nbsp;</a></span>ARM_NAND_DevicePower()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ARM_NAND_DevicePower </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>voltage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set device power supply voltage. </p>
<p>The function <b>ARM_NAND_DevicePower</b> controls the power supply of the NAND device.</p>
<p>The parameter <em>voltage</em> sets the device supply voltage as defined in the table.</p>
<p><b>AMR_NAND_POWER_xxx_xxx</b> specifies power settings.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Device Power Bits   </th><th class="markdownTableHeadLeft">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">ARM_NAND_POWER_VCC_OFF   </td><td class="markdownTableBodyLeft">Set VCC Power off    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">ARM_NAND_POWER_VCC_3V3   </td><td class="markdownTableBodyLeft">Set VCC = 3.3V    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">ARM_NAND_POWER_VCC_1V8   </td><td class="markdownTableBodyLeft">Set VCC = 1.8V    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">ARM_NAND_POWER_VCCQ_OFF   </td><td class="markdownTableBodyLeft">Set VCCQ I/O Power off    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">ARM_NAND_POWER_VCCQ_3V3   </td><td class="markdownTableBodyLeft">Set VCCQ = 3.3V    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">ARM_NAND_POWER_VCCQ_1V8   </td><td class="markdownTableBodyLeft">Set VCCQ = 1.8V    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">ARM_NAND_POWER_VPP_OFF   </td><td class="markdownTableBodyLeft">Set VPP off    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">ARM_NAND_POWER_VPP_ON   </td><td class="markdownTableBodyLeft">Set VPP on   </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">voltage</td><td>NAND Device supply voltage </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__execution__status.html">Status Error Codes</a> </dd></dl>

</div>
</div>
<a id="ga8a0108dba757a4610475151144b52825"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8a0108dba757a4610475151144b52825">&#9670;&nbsp;</a></span>ARM_NAND_ExecuteSequence()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ARM_NAND_ExecuteSequence </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>dev_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr_col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr_row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>data_cnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>status</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Execute sequence of operations. </p>
<p>The function <b>ARM_NAND_ExecuteSequence</b> executes a sequence of operations for a NAND device.</p>
<p>The parameter <em>dev_num</em> is the device number. <br  />
The parameter <em>code</em> is the sequence encoding as defined in the table <b>Sequence execution Code</b>. <br  />
The parameter <em>cmd</em> is the command or a series of commands. <br  />
The parameter <em>addr_col</em> is the column address. <br  />
The parameter <em>addr_row</em> is the row address. <br  />
The parameter <em>data</em> is a pointer to the buffer that stores the data to or loads the data from. <br  />
The parameter <em>data_cnt</em> is the number of data items to read or write in one iteration. <br  />
The parameter <em>status</em> is a pointer to the buffer that stores the status read. <br  />
The parameter <em>count</em> is a pointer to the number of iterations. <br  />
 <b>ARM_NAND_CODE_xxx</b> specifies sequence execution codes.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Sequence Execution Code   </th><th class="markdownTableHeadLeft">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">ARM_NAND_CODE_SEND_CMD1   </td><td class="markdownTableBodyLeft">Send Command 1 (cmd[7..0])    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">ARM_NAND_CODE_SEND_ADDR_COL1   </td><td class="markdownTableBodyLeft">Send Column Address 1 (addr_col[7..0])    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">ARM_NAND_CODE_SEND_ADDR_COL2   </td><td class="markdownTableBodyLeft">Send Column Address 2 (addr_col[15..8])    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">ARM_NAND_CODE_SEND_ADDR_ROW1   </td><td class="markdownTableBodyLeft">Send Row Address 1 (addr_row[7..0])    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">ARM_NAND_CODE_SEND_ADDR_ROW2   </td><td class="markdownTableBodyLeft">Send Row Address 2 (addr_row[15..8])    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">ARM_NAND_CODE_SEND_ADDR_ROW3   </td><td class="markdownTableBodyLeft">Send Row Address 3 (addr_row[23..16])    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">ARM_NAND_CODE_INC_ADDR_ROW   </td><td class="markdownTableBodyLeft">Auto-increment Row Address    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">ARM_NAND_CODE_WRITE_DATA   </td><td class="markdownTableBodyLeft">Write Data    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">ARM_NAND_CODE_SEND_CMD2   </td><td class="markdownTableBodyLeft">Send Command 2 (cmd[15..8])    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">ARM_NAND_CODE_WAIT_BUSY   </td><td class="markdownTableBodyLeft">Wait while R/Bn busy    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">ARM_NAND_CODE_READ_DATA   </td><td class="markdownTableBodyLeft">Read Data    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">ARM_NAND_CODE_SEND_CMD3   </td><td class="markdownTableBodyLeft">Send Command 3 (cmd[23..16])    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">ARM_NAND_CODE_READ_STATUS   </td><td class="markdownTableBodyLeft">Read Status byte and check FAIL bit (bit 0)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><a class="el" href="group__nand__driver__ecc__codes.html#gac2eb4475f12a443209165d29fe200030">ARM_NAND_ECC(n)</a>   </td><td class="markdownTableBodyLeft">Select ECC    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><a class="el" href="group__nand__driver__ecc__codes.html#ga15c79a12200c16f953936635f930df1d">ARM_NAND_ECC0</a>   </td><td class="markdownTableBodyLeft">Use ECC0 of selected ECC    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><a class="el" href="group__nand__driver__ecc__codes.html#gaee653288a88318ee33d1db81baa69bbc">ARM_NAND_ECC1</a>   </td><td class="markdownTableBodyLeft">Use ECC1 of selected ECC    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">ARM_NAND_DRIVER_DONE_EVENT   </td><td class="markdownTableBodyLeft">Generate <a class="el" href="group___n_a_n_d__events.html#gac774a334871789d24107b843d1ebd00c">ARM_NAND_EVENT_DRIVER_DONE</a>   </td></tr>
</table>
<p>The data item size is defined by the data type, which depends on the configured data bus width.</p>
<p>Data type is:</p><ul>
<li><em>uint8_t</em> for 8-bit data bus</li>
<li><em>uint16_t</em> for 16-bit data bus</li>
</ul>
<p>The function is non-blocking and returns as soon as the driver has started executing the specified sequence. When the operation is completed, the <a class="el" href="group___n_a_n_d__events.html#gac774a334871789d24107b843d1ebd00c">ARM_NAND_EVENT_DRIVER_DONE</a> event is generated (if enabled by <b>ARM_NAND_DRIVER_DONE_EVENT</b>). Progress of the operation can also be monitored by calling the <a class="el" href="group__nand__interface__gr.html#ga4578642f37a556b58b0bba0ad5d42641">ARM_NAND_GetStatus</a> function and checking the <em>busy</em> data field.</p>
<p>Driver executes the number of specified iterations where in each iteration items specified by <b>ARM_NAND_CODE_xxx</b> are executed in the order as listed in the table <b>Sequence execution Code</b>. The parameter <em>count</em> is holding the current number of iterations left.</p>
<p>Execution is automatically aborted and <a class="el" href="group___n_a_n_d__events.html#gac774a334871789d24107b843d1ebd00c">ARM_NAND_EVENT_DRIVER_DONE</a> event is generated (if enabled by <b>ARM_NAND_DRIVER_DONE_EVENT</b>):</p><ul>
<li>if Read Status is enabled and the FAIL bit (bit 0) is set</li>
<li>if ECC is used and ECC fails (also sets ARM_NAND_EVENT_ECC_ERROR event)</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>ARM_NAND_CODE_WAIT_BUSY can only be specified if the Device Ready event can be generated (reported by <em>event_device_ready</em> in <a class="el" href="struct_a_r_m___n_a_n_d___c_a_p_a_b_i_l_i_t_i_e_s.html">ARM_NAND_CAPABILITIES</a>). The event <a class="el" href="group___n_a_n_d__events.html#gae0be7e1b41188def905de0a1568d442d">ARM_NAND_EVENT_DEVICE_READY</a> is not generated during sequence execution but rather used internally by the driver.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev_num</td><td>Device number </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">code</td><td>Sequence code </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>Command(s) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addr_col</td><td>Column address </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addr_row</td><td>Row address </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>Pointer to data to be written or read </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data_cnt</td><td>Number of data items in one iteration </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">status</td><td>Pointer to status read </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">count</td><td>Number of iterations </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__execution__status.html">Status Error Codes</a> </dd></dl>

</div>
</div>
<a id="ga9f2609975c2008d21b9ae28f15daf147"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9f2609975c2008d21b9ae28f15daf147">&#9670;&nbsp;</a></span>ARM_NAND_GetCapabilities()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_a_r_m___n_a_n_d___c_a_p_a_b_i_l_i_t_i_e_s.html">ARM_NAND_CAPABILITIES</a> ARM_NAND_GetCapabilities </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get driver capabilities. </p>
<p>The function <b>ARM_NAND_GetCapabilities</b> retrieves information about capabilities in this driver implementation. The data fields of the structure <a class="el" href="struct_a_r_m___n_a_n_d___c_a_p_a_b_i_l_i_t_i_e_s.html">ARM_NAND_CAPABILITIES</a> encode various capabilities, for example if a hardware is able to create signal events using the <a class="el" href="group__nand__interface__gr.html#gaf4ce80b0fd6717de7ddfb1cfaf7dd754">ARM_NAND_SignalEvent</a> callback function.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keyword">extern</span> <a class="code" href="struct_a_r_m___d_r_i_v_e_r___n_a_n_d.html">ARM_DRIVER_NAND</a> Driver_NAND0;</div>
<div class="line"><a class="code" href="struct_a_r_m___d_r_i_v_e_r___n_a_n_d.html">ARM_DRIVER_NAND</a> *drv_info;</div>
<div class="line">  </div>
<div class="line"><span class="keywordtype">void</span> read_capabilities (<span class="keywordtype">void</span>)  {</div>
<div class="line">  <a class="code" href="struct_a_r_m___n_a_n_d___c_a_p_a_b_i_l_i_t_i_e_s.html">ARM_NAND_CAPABILITIES</a> drv_capabilities;</div>
<div class="line"> </div>
<div class="line">  drv_info = &amp;Driver_NAND0;  </div>
<div class="line">  drv_capabilities = drv_info-&gt;GetCapabilities ();</div>
<div class="line">  <span class="comment">// interrogate capabilities</span></div>
<div class="line"> </div>
<div class="line">}</div>
<div class="ttc" id="astruct_a_r_m___n_a_n_d___c_a_p_a_b_i_l_i_t_i_e_s_html"><div class="ttname"><a href="struct_a_r_m___n_a_n_d___c_a_p_a_b_i_l_i_t_i_e_s.html">ARM_NAND_CAPABILITIES</a></div></div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd><a class="el" href="struct_a_r_m___n_a_n_d___c_a_p_a_b_i_l_i_t_i_e_s.html">ARM_NAND_CAPABILITIES</a> </dd></dl>

</div>
</div>
<a id="ga43011066306bd716b580e6aa9a80cf65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga43011066306bd716b580e6aa9a80cf65">&#9670;&nbsp;</a></span>ARM_NAND_GetDeviceBusy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ARM_NAND_GetDeviceBusy </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>dev_num</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get Device Busy pin state. </p>
<p>The function <b>ARM_NAND_GetDeviceBusy</b> returns the status of the Device Busy pin: [\token{1=busy; 0=not busy or error}].</p>
<p>The parameter <em>dev_num</em> is the device number.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev_num</td><td>Device number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1=busy, 0=not busy, or error </dd></dl>

</div>
</div>
<a id="ga4578642f37a556b58b0bba0ad5d42641"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4578642f37a556b58b0bba0ad5d42641">&#9670;&nbsp;</a></span>ARM_NAND_GetStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_a_r_m___n_a_n_d___s_t_a_t_u_s.html">ARM_NAND_STATUS</a> ARM_NAND_GetStatus </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>dev_num</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get NAND status. </p>
<p>The function <b>ARM_NAND_GetStatus</b> returns the current NAND device status.</p>
<p>The parameter <em>dev_num</em> is the device number.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev_num</td><td>Device number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NAND status <a class="el" href="struct_a_r_m___n_a_n_d___s_t_a_t_u_s.html">ARM_NAND_STATUS</a> </dd></dl>

</div>
</div>
<a id="ga01255fd4f15e7fa4751c7ea59648ef5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga01255fd4f15e7fa4751c7ea59648ef5a">&#9670;&nbsp;</a></span>ARM_NAND_GetVersion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_a_r_m___d_r_i_v_e_r___v_e_r_s_i_o_n.html">ARM_DRIVER_VERSION</a> ARM_NAND_GetVersion </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get driver version. </p>
<p>The function <b>ARM_NAND_GetVersion</b> returns version information of the driver implementation in <a class="el" href="struct_a_r_m___d_r_i_v_e_r___v_e_r_s_i_o_n.html">ARM_DRIVER_VERSION</a></p><ul>
<li>API version is the version of the CMSIS-Driver specification used to implement this driver.</li>
<li>Driver version is source code version of the actual driver implementation.</li>
</ul>
<p>Example: </p><div class="fragment"><div class="line"><span class="keyword">extern</span> <a class="code" href="struct_a_r_m___d_r_i_v_e_r___n_a_n_d.html">ARM_DRIVER_NAND</a> Driver_NAND0;</div>
<div class="line"><a class="code" href="struct_a_r_m___d_r_i_v_e_r___n_a_n_d.html">ARM_DRIVER_NAND</a> *drv_info;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> setup_nand (<span class="keywordtype">void</span>)  {</div>
<div class="line">  <a class="code" href="struct_a_r_m___d_r_i_v_e_r___v_e_r_s_i_o_n.html">ARM_DRIVER_VERSION</a>  version;</div>
<div class="line"> </div>
<div class="line">  drv_info = &amp;Driver_NAND0;  </div>
<div class="line">  version = drv_info-&gt;GetVersion ();</div>
<div class="line">  <span class="keywordflow">if</span> (version.api &lt; 0x10A)   {      <span class="comment">// requires at minimum API version 1.10 or higher</span></div>
<div class="line">    <span class="comment">// error handling</span></div>
<div class="line">    <span class="keywordflow">return</span>;</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="ttc" id="astruct_a_r_m___d_r_i_v_e_r___v_e_r_s_i_o_n_html"><div class="ttname"><a href="struct_a_r_m___d_r_i_v_e_r___v_e_r_s_i_o_n.html">ARM_DRIVER_VERSION</a></div></div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd><a class="el" href="struct_a_r_m___d_r_i_v_e_r___v_e_r_s_i_o_n.html">ARM_DRIVER_VERSION</a> </dd></dl>

</div>
</div>
<a id="ga74ad34718a595e7a4375b90f33e72750"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga74ad34718a595e7a4375b90f33e72750">&#9670;&nbsp;</a></span>ARM_NAND_Initialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ARM_NAND_Initialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__nand__interface__gr.html#ga09f4cf2f2df0bb690bce38b13d77e50f">ARM_NAND_SignalEvent_t</a>&#160;</td>
          <td class="paramname"><em>cb_event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the NAND Interface. </p>
<p>The function <b>ARM_NAND_Initialize</b> initializes the NAND interface. It is called when the middleware component starts operation.</p>
<p>The function performs the following operations:</p><ul>
<li>Initializes the resources needed for the NAND interface.</li>
<li>Registers the <a class="el" href="group__nand__interface__gr.html#gaf4ce80b0fd6717de7ddfb1cfaf7dd754">ARM_NAND_SignalEvent</a> callback function.</li>
</ul>
<p>The parameter <em>cb_event</em> is a pointer to the <a class="el" href="group__nand__interface__gr.html#gaf4ce80b0fd6717de7ddfb1cfaf7dd754">ARM_NAND_SignalEvent</a> callback function; use a NULL pointer when no callback signals are required.</p>
<p><b>Example:</b> </p><ul>
<li>see <a class="el" href="group__nand__interface__gr.html">NAND Interface</a> - Driver Functions</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cb_event</td><td>Pointer to <a class="el" href="group__nand__interface__gr.html#gaf4ce80b0fd6717de7ddfb1cfaf7dd754">ARM_NAND_SignalEvent</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__execution__status.html">Status Error Codes</a> </dd></dl>

</div>
</div>
<a id="gac21425454d586ef48fdfc35e7bd78947"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac21425454d586ef48fdfc35e7bd78947">&#9670;&nbsp;</a></span>ARM_NAND_InquireECC()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ARM_NAND_InquireECC </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_a_r_m___n_a_n_d___e_c_c___i_n_f_o.html">ARM_NAND_ECC_INFO</a> *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inquire about available ECC. </p>
<p>The function <b>ARM_NAND_InquireECC</b> reads error correction code information.</p>
<p>The parameter <em>index</em> is the ECC index and is used to retrieve different ECC configurations. <br  />
The parameter <em>info</em> is a pointer of type <a class="el" href="struct_a_r_m___n_a_n_d___e_c_c___i_n_f_o.html">ARM_NAND_ECC_INFO</a>. The data fields store the information.</p>
<p>When multiple different ECC configurations exist, <a class="el" href="struct_a_r_m___n_a_n_d___e_c_c___i_n_f_o.html">ARM_NAND_ECC_INFO</a> structure exists for each configuration. Parameter <em>index</em> denotes which configuration will be retrieved. Value of index should start with zero to retrieve first ECC configuration and should be incremented in order to retrieve next ECC configuration. When index is out of range function ARM_NAND_InquireECC returns with error.</p>
<p>Parameter <em>index</em> is used by <a class="el" href="group__nand__driver__ecc__codes.html#gac2eb4475f12a443209165d29fe200030">ARM_NAND_ECC(n)</a> in <a class="el" href="group__nand__interface__gr.html#gae1899a20ef107400c8bf84fad477a8ce">ARM_NAND_ReadData</a>, <a class="el" href="group__nand__interface__gr.html#ga1fa497dd51a86fc308e946b4419fd006">ARM_NAND_WriteData</a> and <a class="el" href="group__nand__interface__gr.html#ga8a0108dba757a4610475151144b52825">ARM_NAND_ExecuteSequence</a> to select suitable ECC configuration.</p>
<p><b>Example</b> </p><div class="fragment"><div class="line"><span class="keyword">extern</span> <a class="code" href="struct_a_r_m___d_r_i_v_e_r___n_a_n_d.html">ARM_DRIVER_NAND</a> Driver_NAND0; </div>
<div class="line"> </div>
<div class="line"><a class="code" href="struct_a_r_m___n_a_n_d___e_c_c___i_n_f_o.html">ARM_NAND_ECC_INFO</a> ecc;</div>
<div class="line">int32_t idx;</div>
<div class="line"> </div>
<div class="line">idx = 0;</div>
<div class="line"><span class="keywordflow">while</span> (Driver_NAND0.InquireECC (idx, &amp;ecc) == <a class="code" href="group__execution__status.html#ga85752c5de59e8adeb001e35ff5be6be7">ARM_DRIVER_OK</a>) {</div>
<div class="line">  <span class="comment">// Examine retrieved ECC configuration</span></div>
<div class="line">  <span class="keywordflow">if</span> (ecc.type == 2) {</div>
<div class="line">    <span class="comment">// Algorithm ECC0 protects Main+Spare</span></div>
<div class="line">  }</div>
<div class="line">  <span class="comment">// ..</span></div>
<div class="line">  idx++;</div>
<div class="line">}</div>
<div class="ttc" id="agroup__execution__status_html_ga85752c5de59e8adeb001e35ff5be6be7"><div class="ttname"><a href="group__execution__status.html#ga85752c5de59e8adeb001e35ff5be6be7">ARM_DRIVER_OK</a></div><div class="ttdeci">#define ARM_DRIVER_OK</div><div class="ttdoc">Operation succeeded.</div><div class="ttdef"><b>Definition:</b> Driver_Common.h:52</div></div>
<div class="ttc" id="astruct_a_r_m___n_a_n_d___e_c_c___i_n_f_o_html"><div class="ttname"><a href="struct_a_r_m___n_a_n_d___e_c_c___i_n_f_o.html">ARM_NAND_ECC_INFO</a></div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Inquire ECC index </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info</td><td>Pointer to ECC information <a class="el" href="struct_a_r_m___n_a_n_d___e_c_c___i_n_f_o.html">ARM_NAND_ECC_INFO</a> retrieved </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__execution__status.html">Status Error Codes</a> </dd></dl>

</div>
</div>
<a id="ga9c9975637980b5d42db7baba0191fda1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9c9975637980b5d42db7baba0191fda1">&#9670;&nbsp;</a></span>ARM_NAND_PowerControl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ARM_NAND_PowerControl </td>
          <td>(</td>
          <td class="paramtype">ARM_POWER_STATE&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Control the NAND interface power. </p>
<p>The function <b>ARM_NAND_PowerControl</b> controls the power modes of the NAND interface. <br  />
</p>
<p>The parameter <em>state</em> sets the operation and can have the following values:</p><ul>
<li>ARM_POWER_FULL : set-up peripheral for data transfers, enable interrupts (NVIC) and optionally DMA. Can be called multiple times. If the peripheral is already in this mode the function performs no operation and returns with <a class="el" href="group__execution__status.html#ga85752c5de59e8adeb001e35ff5be6be7">ARM_DRIVER_OK</a>.</li>
<li>ARM_POWER_LOW : may use power saving. Returns <a class="el" href="group__execution__status.html#ga2efa59e480d82697795439220e6884e4">ARM_DRIVER_ERROR_UNSUPPORTED</a> when not implemented.</li>
<li>ARM_POWER_OFF : terminates any pending data transfers, disables peripheral, disables related interrupts and DMA.</li>
</ul>
<p>Refer to CallSequence for more information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>Power state </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__execution__status.html">Status Error Codes</a> </dd></dl>

</div>
</div>
<a id="gae1899a20ef107400c8bf84fad477a8ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae1899a20ef107400c8bf84fad477a8ce">&#9670;&nbsp;</a></span>ARM_NAND_ReadData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ARM_NAND_ReadData </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>dev_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>cnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read data from NAND device. </p>
<p>The function <b>ARM_NAND_ReadData</b> reads data from a NAND device.</p>
<p>The parameter <em>dev_num</em> is the device number. <br  />
The parameter <em>data</em> is a pointer to the buffer that stores the data read from a NAND device. <br  />
The parameter <em>cnt</em> is the number of data items to read. <br  />
The parameter <em>mode</em> defines the operation mode as listed in the table below.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Read Data Mode   </th><th class="markdownTableHeadLeft">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><a class="el" href="group__nand__driver__ecc__codes.html#gac2eb4475f12a443209165d29fe200030">ARM_NAND_ECC(n)</a>   </td><td class="markdownTableBodyLeft">Select ECC    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><a class="el" href="group__nand__driver__ecc__codes.html#ga15c79a12200c16f953936635f930df1d">ARM_NAND_ECC0</a>   </td><td class="markdownTableBodyLeft">Use ECC0 of selected ECC    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><a class="el" href="group__nand__driver__ecc__codes.html#gaee653288a88318ee33d1db81baa69bbc">ARM_NAND_ECC1</a>   </td><td class="markdownTableBodyLeft">Use ECC1 of selected ECC    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">ARM_NAND_DRIVER_DONE_EVENT   </td><td class="markdownTableBodyLeft">Generate <a class="el" href="group___n_a_n_d__events.html#gac774a334871789d24107b843d1ebd00c">ARM_NAND_EVENT_DRIVER_DONE</a>   </td></tr>
</table>
<p>The data item size is defined by the data type, which depends on the configured data bus width.</p>
<p>Data type is:</p><ul>
<li><em>uint8_t</em> for 8-bit data bus</li>
<li><em>uint16_t</em> for 16-bit data bus</li>
</ul>
<p>The function executes in the following ways:</p><ul>
<li>When the operation is blocking (typical for devices connected to memory bus when not using DMA), then the function returns after all data is read and returns the number of data items read.</li>
<li>When the operation is non-blocking (typical for NAND controllers), then the function only starts the operation and returns with zero number of data items read. After the operation is completed, the <a class="el" href="group___n_a_n_d__events.html#gac774a334871789d24107b843d1ebd00c">ARM_NAND_EVENT_DRIVER_DONE</a> event is generated (if enabled by <b>ARM_NAND_DRIVER_DONE_EVENT</b>). Progress of the operation can also be monitored by calling the <a class="el" href="group__nand__interface__gr.html#ga4578642f37a556b58b0bba0ad5d42641">ARM_NAND_GetStatus</a> function and checking the <em>busy</em> data field. Operation is automatically aborted if ECC is used and ECC correction fails, which generates the ARM_NAND_EVENT_ECC_ERROR event (together with ARM_NAND_DRIVER_DONE_EVENT if enabled).</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev_num</td><td>Device number </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>Pointer to buffer for data to read from NAND device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cnt</td><td>Number of data items to read </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>Operation mode </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of data items read or <a class="el" href="group__execution__status.html">Status Error Codes</a> </dd></dl>

</div>
</div>
<a id="ga00e195031e03d364db7595858a7e76f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga00e195031e03d364db7595858a7e76f3">&#9670;&nbsp;</a></span>ARM_NAND_SendAddress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ARM_NAND_SendAddress </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>dev_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send address to NAND device. </p>
<p>Send an address to the NAND device. The parameter <em>dev_num</em> is the device number. The parameter <em>addr</em> is the address.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev_num</td><td>Device number </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>Address </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__execution__status.html">Status Error Codes</a> </dd></dl>

</div>
</div>
<a id="ga9f70b89ba478eadfe7f5dee7453a4fb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9f70b89ba478eadfe7f5dee7453a4fb7">&#9670;&nbsp;</a></span>ARM_NAND_SendCommand()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ARM_NAND_SendCommand </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>dev_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>cmd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send command to NAND device. </p>
<p>The function <b>ARM_NAND_SendCommand</b> sends a command to the NAND device.</p>
<p>The parameter <em>dev_num</em> is the device number. <br  />
The parameter <em>cmd</em> is the command sent to the NAND device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev_num</td><td>Device number </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>Command </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__execution__status.html">Status Error Codes</a> </dd></dl>

</div>
</div>
<a id="gaf4ce80b0fd6717de7ddfb1cfaf7dd754"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf4ce80b0fd6717de7ddfb1cfaf7dd754">&#9670;&nbsp;</a></span>ARM_NAND_SignalEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ARM_NAND_SignalEvent </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>dev_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>event</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signal NAND event. </p>
<p>The function <b>ARM_NAND_SignalEvent</b> is a callback function registered by the function <a class="el" href="group__nand__interface__gr.html#ga74ad34718a595e7a4375b90f33e72750">ARM_NAND_Initialize</a>.</p>
<p>The parameter <em>dev_num</em> is the device number. <br  />
The parameter <em>event</em> indicates one or more events that occurred during driver operation. Each event is encoded in a separate bit and therefore it is possible to signal multiple events within the same call.</p>
<p>Not every event is necessarily generated by the driver. This depends on the implemented capabilities stored in the data fields of the structure <a class="el" href="struct_a_r_m___n_a_n_d___c_a_p_a_b_i_l_i_t_i_e_s.html">ARM_NAND_CAPABILITIES</a>, which can be retrieved with the function <a class="el" href="group__nand__interface__gr.html#ga9f2609975c2008d21b9ae28f15daf147">ARM_NAND_GetCapabilities</a>.</p>
<p>The following events can be generated:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Parameter <em>event</em>   </th><th class="markdownTableHeadNone">Bit   </th><th class="markdownTableHeadLeft">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><a class="el" href="group___n_a_n_d__events.html#gae0be7e1b41188def905de0a1568d442d">ARM_NAND_EVENT_DEVICE_READY</a>   </td><td class="markdownTableBodyNone">0   </td><td class="markdownTableBodyLeft">Occurs when rising edge is detected on R/Bn (Ready/Busy) pin indicating that the device is ready.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><a class="el" href="group___n_a_n_d__events.html#ga7b390a906db42c5ea4db38e0e85bb9e9">ARM_NAND_EVENT_DRIVER_READY</a>   </td><td class="markdownTableBodyNone">1   </td><td class="markdownTableBodyLeft">Occurs to indicate that commands can be executed (after previously being busy and not able to start the requested operation).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><a class="el" href="group___n_a_n_d__events.html#gac774a334871789d24107b843d1ebd00c">ARM_NAND_EVENT_DRIVER_DONE</a>   </td><td class="markdownTableBodyNone">2   </td><td class="markdownTableBodyLeft">Occurs after an operation completes. An operation was successfully started before with <a class="el" href="group__nand__interface__gr.html#gae1899a20ef107400c8bf84fad477a8ce">ARM_NAND_ReadData</a>, <a class="el" href="group__nand__interface__gr.html#ga1fa497dd51a86fc308e946b4419fd006">ARM_NAND_WriteData</a>, <a class="el" href="group__nand__interface__gr.html#ga8a0108dba757a4610475151144b52825">ARM_NAND_ExecuteSequence</a>.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">ARM_NAND_EVENT_ECC_ERROR   </td><td class="markdownTableBodyNone">3   </td><td class="markdownTableBodyLeft">Occurs when ECC generation failed or ECC correction failed. An operation was successfully started before with <a class="el" href="group__nand__interface__gr.html#gae1899a20ef107400c8bf84fad477a8ce">ARM_NAND_ReadData</a>, <a class="el" href="group__nand__interface__gr.html#ga1fa497dd51a86fc308e946b4419fd006">ARM_NAND_WriteData</a>, <a class="el" href="group__nand__interface__gr.html#ga8a0108dba757a4610475151144b52825">ARM_NAND_ExecuteSequence</a>.   </td></tr>
</table>
<p>The event <a class="el" href="group___n_a_n_d__events.html#gae0be7e1b41188def905de0a1568d442d">ARM_NAND_EVENT_DEVICE_READY</a> occurs after complete execution of commands (initiated with the functions <a class="el" href="group__nand__interface__gr.html#ga9f70b89ba478eadfe7f5dee7453a4fb7">ARM_NAND_SendCommand</a>, <a class="el" href="group__nand__interface__gr.html#ga00e195031e03d364db7595858a7e76f3">ARM_NAND_SendAddress</a>, <a class="el" href="group__nand__interface__gr.html#gae1899a20ef107400c8bf84fad477a8ce">ARM_NAND_ReadData</a>, <a class="el" href="group__nand__interface__gr.html#ga1fa497dd51a86fc308e946b4419fd006">ARM_NAND_WriteData</a>, <a class="el" href="group__nand__interface__gr.html#ga8a0108dba757a4610475151144b52825">ARM_NAND_ExecuteSequence</a>). It is useful to indicate completion of complex operations (such as erase). The event is only generated when <a class="el" href="group__nand__interface__gr.html#ga9f2609975c2008d21b9ae28f15daf147">ARM_NAND_GetCapabilities</a> returns data field <em>event_device_ready</em> = \token{1} and was enabled by calling <a class="el" href="group__nand__interface__gr.html#ga83061d6d53ffb148853efbc87a864607">ARM_NAND_Control</a> (ARM_NAND_DEVICE_READY_EVENT, 1). If the event is not available, poll the <em>busy</em> data field using the function <a class="el" href="group__nand__interface__gr.html#ga4578642f37a556b58b0bba0ad5d42641">ARM_NAND_GetStatus</a>.</p>
<p>The event <a class="el" href="group___n_a_n_d__events.html#ga7b390a906db42c5ea4db38e0e85bb9e9">ARM_NAND_EVENT_DRIVER_READY</a> occurs when previously a function (<a class="el" href="group__nand__interface__gr.html#ga9f70b89ba478eadfe7f5dee7453a4fb7">ARM_NAND_SendCommand</a>, <a class="el" href="group__nand__interface__gr.html#ga00e195031e03d364db7595858a7e76f3">ARM_NAND_SendAddress</a>, <a class="el" href="group__nand__interface__gr.html#gae1899a20ef107400c8bf84fad477a8ce">ARM_NAND_ReadData</a>, <a class="el" href="group__nand__interface__gr.html#ga1fa497dd51a86fc308e946b4419fd006">ARM_NAND_WriteData</a>, <a class="el" href="group__nand__interface__gr.html#ga8a0108dba757a4610475151144b52825">ARM_NAND_ExecuteSequence</a>) returned with <a class="el" href="group__execution__status.html#ga13c1123319c7b9a4735d63447f35116b">ARM_DRIVER_ERROR_BUSY</a>. It is useful when functions are called simultaneously from independent threads (for example to control multiple devices) and the threads have no knowledge about each other (driver rejects reentrant calls with return of <a class="el" href="group__execution__status.html#ga13c1123319c7b9a4735d63447f35116b">ARM_DRIVER_ERROR_BUSY</a>). <em>dev_num</em> indicates the device that returned previously busy.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev_num</td><td>Device number </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td>Event notification mask </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

</div>
</div>
<a id="gaa788b638ab696b166fee2f4a4bc8d97a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa788b638ab696b166fee2f4a4bc8d97a">&#9670;&nbsp;</a></span>ARM_NAND_Uninitialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ARM_NAND_Uninitialize </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>De-initialize the NAND Interface. </p>
<p>The function <b>ARM_NAND_Uninitialize</b> de-initializes the resources of NAND interface.</p>
<p>It is called when the middleware component stops operation and releases the software resources used by the interface.</p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__execution__status.html">Status Error Codes</a> </dd></dl>

</div>
</div>
<a id="ga1fa497dd51a86fc308e946b4419fd006"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1fa497dd51a86fc308e946b4419fd006">&#9670;&nbsp;</a></span>ARM_NAND_WriteData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ARM_NAND_WriteData </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>dev_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>cnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write data to NAND device. </p>
<p>The function <b>ARM_NAND_WriteData</b> writes data to a NAND device.</p>
<p>The parameter <em>dev_num</em> is the device number. <br  />
The parameter <em>data</em> is a pointer to the buffer with data to write. <br  />
The parameter <em>cnt</em> is the number of data items to write. <br  />
The parameter <em>mode</em> defines the operation mode as listed in the table below.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Write Data Mode   </th><th class="markdownTableHeadLeft">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><a class="el" href="group__nand__driver__ecc__codes.html#gac2eb4475f12a443209165d29fe200030">ARM_NAND_ECC(n)</a>   </td><td class="markdownTableBodyLeft">Select ECC    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><a class="el" href="group__nand__driver__ecc__codes.html#ga15c79a12200c16f953936635f930df1d">ARM_NAND_ECC0</a>   </td><td class="markdownTableBodyLeft">Use ECC0 of selected ECC    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><a class="el" href="group__nand__driver__ecc__codes.html#gaee653288a88318ee33d1db81baa69bbc">ARM_NAND_ECC1</a>   </td><td class="markdownTableBodyLeft">Use ECC1 of selected ECC    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">ARM_NAND_DRIVER_DONE_EVENT   </td><td class="markdownTableBodyLeft">Generate <a class="el" href="group___n_a_n_d__events.html#gac774a334871789d24107b843d1ebd00c">ARM_NAND_EVENT_DRIVER_DONE</a>   </td></tr>
</table>
<p>The data item size is defined by the data type, which depends on the configured data bus width.</p>
<p>Data type is:</p><ul>
<li><em>uint8_t</em> for 8-bit data bus</li>
<li><em>uint16_t</em> for 16-bit data bus</li>
</ul>
<p>The function executes in the following ways:</p><ul>
<li>When the operation is blocking (typical for devices connected to memory bus when not using DMA), then the function returns after all data is written and returns the number of data items written.</li>
<li>When the operation is non-blocking (typical for NAND controllers), then the function only starts the operation and returns with zero number of data items written. After the operation is completed, the <a class="el" href="group___n_a_n_d__events.html#gac774a334871789d24107b843d1ebd00c">ARM_NAND_EVENT_DRIVER_DONE</a> event is generated (if enabled by <b>ARM_NAND_DRIVER_DONE_EVENT</b>). Progress of the operation can also be monitored by calling the <a class="el" href="group__nand__interface__gr.html#ga4578642f37a556b58b0bba0ad5d42641">ARM_NAND_GetStatus</a> function and checking the <em>busy</em> data field. Operation is automatically aborted if ECC is used and ECC generation fails, which generates the ARM_NAND_EVENT_ECC_ERROR event (together with ARM_NAND_DRIVER_DONE_EVENT if enabled).</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev_num</td><td>Device number </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>Pointer to buffer with data to write to NAND device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cnt</td><td>Number of data items to write </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>Operation mode </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of data items written or <a class="el" href="group__execution__status.html">Status Error Codes</a> </dd></dl>

</div>
</div>
<a id="ga1987e65a4e756d748db86332c9fb1cec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1987e65a4e756d748db86332c9fb1cec">&#9670;&nbsp;</a></span>ARM_NAND_WriteProtect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ARM_NAND_WriteProtect </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>dev_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Control WPn (Write Protect). </p>
<p>The function <b>ARM_NAND_WriteProtect</b> controls the Write Protect (WPn) pin of a NAND device.</p>
<p>The parameter <em>dev_num</em> is the device number. <br  />
 The parameter <em>enable</em> specifies whether to enable or disable write protection.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev_num</td><td>Device number </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">enable</td><td><ul>
<li><b>false</b> Write Protect off</li>
<li><b>true</b> Write Protect on </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__execution__status.html">Status Error Codes</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
